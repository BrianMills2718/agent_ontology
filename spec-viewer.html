<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Ontology Spec Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            background: #0d1117;
            color: #c9d1d9;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* ── Main canvas area ── */
        #canvas-wrap {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        canvas {
            display: block;
            cursor: default;
        }
        #tooltip {
            display: none;
            position: absolute;
            pointer-events: none;
            background: #1c2028;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 10px 14px;
            font-size: 0.75em;
            max-width: 360px;
            z-index: 20;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            line-height: 1.5;
        }

        /* ── Header bar ── */
        #header {
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 44px;
            background: rgba(13,17,23,0.92);
            border-bottom: 1px solid #21262d;
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 16px;
            z-index: 10;
            backdrop-filter: blur(8px);
        }
        #header h1 {
            font-size: 0.95em;
            color: #e6edf3;
            font-weight: 600;
            white-space: nowrap;
        }
        #header h1 span { color: #7ee787; }
        #header select, #header .hdr-btn {
            background: #161b22;
            color: #c9d1d9;
            border: 1px solid #30363d;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-family: inherit;
            cursor: pointer;
        }
        #header .hdr-btn:hover { border-color: #58a6ff; color: #e6edf3; }
        #header .stats {
            font-size: 0.7em;
            color: #484f58;
            margin-left: auto;
        }

        /* ── Sidebar ── */
        #sidebar {
            width: 380px;
            background: #161b22;
            border-left: 1px solid #21262d;
            overflow-y: auto;
            padding: 60px 16px 16px;
        }
        #sidebar.collapsed { width: 0; padding: 0; overflow: hidden; }
        .sb-title {
            font-size: 1.05em;
            font-weight: 600;
            color: #e6edf3;
            margin-bottom: 4px;
        }
        .sb-type {
            font-size: 0.7em;
            color: #484f58;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }
        .sb-desc {
            font-size: 0.8em;
            color: #8b949e;
            line-height: 1.6;
            margin-bottom: 16px;
        }
        .sb-section {
            font-size: 0.75em;
            font-weight: 600;
            color: #58a6ff;
            margin: 16px 0 8px;
            border-bottom: 1px solid #21262d;
            padding-bottom: 4px;
        }
        .sb-field {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 0.75em;
            border-bottom: 1px solid rgba(33,38,45,0.5);
        }
        .sb-field .key { color: #8b949e; }
        .sb-field .val { color: #c9d1d9; text-align: right; max-width: 220px; word-break: break-word; }
        .sb-edge {
            padding: 6px 8px;
            margin: 4px 0;
            border-radius: 4px;
            font-size: 0.75em;
            cursor: pointer;
            border-left: 3px solid;
        }
        .sb-edge:hover { background: #1c2028; }
        .sb-edge .edge-label { color: #c9d1d9; font-weight: 600; }
        .sb-edge .edge-detail { color: #484f58; font-size: 0.9em; }
        .sb-schema {
            background: #0d1117;
            border-radius: 4px;
            padding: 8px 10px;
            margin: 4px 0;
            font-size: 0.72em;
        }
        .sb-schema .field-name { color: #7ee787; }
        .sb-schema .field-type { color: #d2a8ff; }
        .sb-logic {
            background: #0d1117;
            border-radius: 4px;
            padding: 8px 10px;
            margin: 4px 0;
            font-size: 0.72em;
            white-space: pre-wrap;
            color: #8b949e;
            line-height: 1.5;
            max-height: 200px;
            overflow-y: auto;
        }

        /* ── Legend ── */
        #legend {
            position: absolute;
            bottom: 12px; left: 12px;
            background: rgba(22,27,34,0.92);
            border: 1px solid #21262d;
            border-radius: 6px;
            padding: 10px 14px;
            font-size: 0.65em;
            display: flex;
            gap: 14px;
            z-index: 10;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #484f58;
        }
        .legend-swatch {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        /* ── Tabs ── */
        .tab-bar {
            display: flex;
            gap: 2px;
            margin-left: 8px;
        }
        .tab-btn {
            background: transparent;
            color: #484f58;
            border: 1px solid transparent;
            border-bottom: none;
            padding: 4px 14px;
            font-family: inherit;
            font-size: 0.75em;
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            transition: color 0.15s, background 0.15s;
        }
        .tab-btn:hover { color: #c9d1d9; }
        .tab-btn.active {
            color: #e6edf3;
            background: #161b22;
            border-color: #30363d;
        }
        .view-container { display: none; }
        .view-container.active { display: block; }

        /* ═══════════════════════════════════════════════════════
           Enhanced State Machine View
           ═══════════════════════════════════════════════════════ */
        #sm-view {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            overflow: auto;
            padding: 60px 32px 32px;
            background: #0d1117;
        }
        .sm-canvas {
            position: relative;
            margin: 0 auto;
            min-height: 600px;
        }
        .sm-title-bar {
            text-align: center;
            font-size: 0.8em;
            color: #484f58;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 24px;
            padding-bottom: 6px;
            border-bottom: 1px solid #21262d;
        }
        .sm-title-bar strong { color: #e6edf3; font-size: 1.2em; letter-spacing: 0; text-transform: none; }

        /* Process nodes as positioned boxes */
        .sm-proc {
            position: absolute;
            cursor: pointer;
            transition: box-shadow 0.15s, transform 0.1s;
            z-index: 2;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.82em;
            padding: 10px 16px;
            min-width: 140px;
        }
        .sm-proc:hover {
            box-shadow: 0 0 14px rgba(88,166,255,0.35);
            transform: translateY(-1px);
            z-index: 5;
        }
        .sm-proc.sm-selected {
            box-shadow: 0 0 16px rgba(88,166,255,0.5);
            outline: 2px solid #58a6ff;
            outline-offset: 2px;
        }
        .sm-proc-name { font-weight: 600; color: #e6edf3; font-size: 0.95em; margin-bottom: 2px; }
        .sm-proc-type { font-size: 0.7em; color: #484f58; text-transform: uppercase; letter-spacing: 0.5px; }

        /* Step: rounded rectangle, light blue */
        .sm-proc-step {
            background: rgba(52,152,219,0.08);
            border: 2px solid #3498db;
            border-radius: 10px;
            color: #3498db;
        }
        .sm-proc-step .sm-proc-name { color: #7ec8e3; }

        /* Gate: diamond shape via clip-path, yellow */
        .sm-proc-gate {
            background: rgba(241,196,15,0.10);
            border: 2px solid #f1c40f;
            min-width: 160px;
            min-height: 70px;
            clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
            padding: 20px 28px;
        }
        .sm-proc-gate .sm-proc-name { color: #f1c40f; font-size: 0.85em; }
        .sm-proc-gate .sm-proc-type { display: none; }

        /* Checkpoint: octagon, orange */
        .sm-proc-checkpoint {
            background: rgba(230,126,34,0.10);
            border: 2px solid #e67e22;
            clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
            min-width: 150px;
            min-height: 60px;
            padding: 14px 22px;
        }
        .sm-proc-checkpoint .sm-proc-name { color: #e67e22; }

        /* Spawn: double-bordered rectangle, purple */
        .sm-proc-spawn {
            background: rgba(155,89,182,0.08);
            border: 3px double #9b59b6;
            border-radius: 6px;
            color: #9b59b6;
        }
        .sm-proc-spawn .sm-proc-name { color: #c39bd3; }

        /* Policy: rounded with dashed border */
        .sm-proc-policy {
            background: rgba(230,126,34,0.06);
            border: 1px dashed #e67e22;
            border-radius: 6px;
        }
        .sm-proc-policy .sm-proc-name { color: #e67e22; }

        /* Entry point marker */
        .sm-proc-entry {
            outline: 3px solid #7ee787 !important;
            outline-offset: 3px;
        }

        /* Invoke badges on the side */
        .sm-invoke-sidebar {
            position: absolute;
            right: -8px;
            top: 50%;
            transform: translate(100%, -50%);
            display: flex;
            flex-direction: column;
            gap: 3px;
            z-index: 3;
        }
        .sm-invoke-chip {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(78,205,196,0.1);
            border: 1px solid rgba(78,205,196,0.25);
            border-radius: 4px;
            padding: 2px 7px;
            font-size: 0.65em;
            color: #4ecdc4;
            white-space: nowrap;
            cursor: default;
        }
        .sm-invoke-chip .inv-icon {
            width: 10px;
            height: 10px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .sm-invoke-chip-agent { border-color: rgba(78,205,196,0.4); color: #4ecdc4; }
        .sm-invoke-chip-tool { border-color: rgba(243,156,18,0.3); color: #f39c12; background: rgba(243,156,18,0.06); }

        /* Data flow tags on processes */
        .sm-data-flow {
            position: absolute;
            left: -140px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 3px;
            max-width: 130px;
        }
        .sm-data-tag {
            font-size: 0.65em;
            padding: 1px 5px;
            border-radius: 3px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
        }
        .sm-data-tag-in {
            background: rgba(88,166,255,0.1);
            border: 1px solid rgba(88,166,255,0.25);
            color: #58a6ff;
        }
        .sm-data-tag-out {
            background: rgba(126,231,135,0.1);
            border: 1px solid rgba(126,231,135,0.25);
            color: #7ee787;
        }
        .sm-data-tag-in::before { content: '→ '; font-size: 0.9em; }
        .sm-data-tag-out::before { content: '← '; font-size: 0.9em; }

        /* SVG overlay for edges */
        .sm-svg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        .sm-svg-layer line, .sm-svg-layer path {
            fill: none;
            stroke-width: 1.5;
        }
        .sm-edge-flow { stroke: #3498db; }
        .sm-edge-loop { stroke: #f0883e; stroke-dasharray: 6 4; }
        .sm-edge-branch { stroke: #e74c3c; }
        .sm-edge-label {
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            fill: #8b949e;
        }
        .sm-edge-label-bg {
            fill: #0d1117;
            rx: 3;
            ry: 3;
        }

        /* State Machine legend */
        .sm-legend {
            position: sticky;
            top: 44px;
            z-index: 6;
            background: rgba(13,17,23,0.95);
            border: 1px solid #21262d;
            border-radius: 6px;
            padding: 8px 14px;
            margin-bottom: 16px;
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            align-items: center;
            font-size: 0.68em;
        }
        .sm-legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #8b949e;
        }
        .sm-legend-shape {
            width: 18px;
            height: 14px;
            border-radius: 3px;
            display: inline-block;
        }
        .sm-legend-line {
            width: 24px;
            height: 2px;
            display: inline-block;
        }

        /* Trace overlay controls */
        .trace-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-left: 8px;
        }
        .trace-label { font-size: 0.68em; color: #484f58; }
        .trace-badge {
            position: absolute;
            top: -6px;
            left: -6px;
            min-width: 18px;
            height: 18px;
            border-radius: 9px;
            background: #58a6ff;
            color: #0d1117;
            font-size: 0.6em;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 4px;
            z-index: 6;
        }
        .trace-duration {
            position: absolute;
            bottom: -6px;
            right: -6px;
            border-radius: 4px;
            padding: 1px 5px;
            font-size: 0.55em;
            font-weight: 600;
            z-index: 6;
            color: #fff;
        }
        .trace-llm-badge {
            position: absolute;
            bottom: -6px;
            left: -6px;
            border-radius: 4px;
            padding: 1px 5px;
            font-size: 0.55em;
            font-weight: 600;
            z-index: 6;
            background: #9b59b6;
            color: #fff;
        }

        /* ═══════════════════════════════════════════════════════
           Enhanced Schemas View
           ═══════════════════════════════════════════════════════ */
        #schemas-view {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            overflow-y: auto;
            padding: 60px 32px 32px;
            background: #0d1117;
        }
        .schemas-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(360px, 1fr));
            gap: 16px;
            max-width: 1400px;
            margin: 0 auto;
        }
        .schema-card {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 16px;
            transition: border-color 0.15s, box-shadow 0.15s;
            scroll-margin-top: 80px;
        }
        .schema-card:hover { border-color: #58a6ff; box-shadow: 0 0 8px rgba(88,166,255,0.15); }
        .schema-card.schema-highlight {
            border-color: #7ee787;
            box-shadow: 0 0 16px rgba(126,231,135,0.3);
        }
        .schema-card-name {
            font-weight: 600;
            color: #58a6ff;
            font-size: 1em;
            margin-bottom: 2px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .schema-card-name .schema-count {
            font-size: 0.7em;
            color: #484f58;
            font-weight: 400;
        }
        .schema-card-desc {
            font-size: 0.75em;
            color: #8b949e;
            margin-bottom: 12px;
            line-height: 1.5;
        }
        .schema-field-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid rgba(33,38,45,0.5);
            font-size: 0.78em;
        }
        .schema-field-row:last-child { border-bottom: none; }
        .schema-field-name { color: #7ee787; font-weight: 500; }
        .schema-field-type {
            padding: 1px 6px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .schema-field-default { color: #484f58; font-size: 0.85em; margin-left: 6px; }
        .schema-field-optional { color: #484f58; font-size: 0.75em; font-style: italic; margin-left: 4px; }
        /* Type color coding */
        .sft-string { background: rgba(46,204,113,0.1); color: #2ecc71; }
        .sft-integer, .sft-number, .sft-boolean { background: rgba(52,152,219,0.1); color: #3498db; }
        .sft-list { background: rgba(155,89,182,0.1); color: #9b59b6; }
        .sft-enum { background: rgba(230,126,34,0.1); color: #e67e22; }
        .sft-object { background: rgba(149,165,166,0.1); color: #95a5a6; }
        .sft-datetime { background: rgba(241,196,15,0.1); color: #f1c40f; }
        .sft-ref { background: rgba(88,166,255,0.1); color: #58a6ff; cursor: pointer; text-decoration: underline; text-decoration-style: dotted; }
        .sft-ref:hover { color: #79c0ff; text-decoration-style: solid; }

        .schema-refs {
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid #21262d;
        }
        .schema-refs-title {
            font-size: 0.65em;
            color: #484f58;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        .schema-ref-tag {
            display: inline-block;
            font-size: 0.68em;
            padding: 2px 7px;
            margin: 2px;
            border-radius: 3px;
            color: #8b949e;
            border: 1px solid #30363d;
            cursor: pointer;
            transition: border-color 0.15s;
        }
        .schema-ref-tag:hover { border-color: #58a6ff; color: #c9d1d9; }
        .schema-ref-tag-process { border-color: rgba(52,152,219,0.3); color: #3498db; }
        .schema-ref-tag-entity { border-color: rgba(78,205,196,0.3); color: #4ecdc4; }
        .schema-ref-tag-edge { border-color: rgba(149,165,166,0.3); color: #95a5a6; }
        .schemas-summary {
            text-align: center;
            color: #484f58;
            font-size: 0.75em;
            margin-bottom: 16px;
        }
        .schemas-filter {
            text-align: center;
            margin-bottom: 16px;
        }
        .schemas-filter input {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 4px;
            color: #c9d1d9;
            padding: 5px 12px;
            font-family: inherit;
            font-size: 0.8em;
            width: 300px;
        }
        .schemas-filter input::placeholder { color: #484f58; }
        .schemas-filter input:focus { outline: none; border-color: #58a6ff; }

        /* ── Compare View ── */
        #compare-view {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            overflow: auto;
            padding: 60px 24px 32px;
            background: #0d1117;
        }
        .compare-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75em;
            table-layout: fixed;
        }
        .compare-table th, .compare-table td {
            padding: 8px 10px;
            border: 1px solid #21262d;
            text-align: center;
            vertical-align: top;
        }
        .compare-table th {
            background: #161b22;
            color: #e6edf3;
            font-weight: 600;
            position: sticky;
            top: 44px;
            z-index: 2;
        }
        .compare-table th:first-child {
            text-align: left;
            width: 140px;
            color: #8b949e;
        }
        .compare-table td:first-child {
            text-align: left;
            font-weight: 600;
            color: #8b949e;
            background: #161b22;
        }
        .compare-table tr:hover td { background: #1c2028; }
        .compare-table tr:hover td:first-child { background: #1e2430; }
        .cmp-count {
            display: inline-block;
            min-width: 20px;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 600;
        }
        .cmp-yes { color: #7ee787; }
        .cmp-no { color: #484f58; }
        .cmp-tag {
            display: inline-block;
            font-size: 0.85em;
            padding: 1px 5px;
            margin: 1px;
            border-radius: 3px;
            background: rgba(88,166,255,0.08);
            color: #58a6ff;
            border: 1px solid rgba(88,166,255,0.15);
        }
        .compare-header {
            text-align: center;
            margin-bottom: 16px;
        }
        .compare-header h2 {
            color: #e6edf3;
            font-size: 1.1em;
            font-weight: 600;
        }
        .compare-header p {
            color: #484f58;
            font-size: 0.75em;
            margin-top: 4px;
        }
        .cmp-bar {
            display: inline-block;
            height: 12px;
            border-radius: 2px;
            vertical-align: middle;
            margin-right: 4px;
        }

        /* ── Overview view ── */
        .ov-canvas {
            position: relative;
            margin: 0 auto;
            padding: 20px;
        }
        .ov-title-bar {
            position: sticky;
            top: 0;
            z-index: 10;
            background: rgba(13,17,23,0.95);
            padding: 10px 20px;
            font-size: 0.85em;
            color: #8b949e;
            border-bottom: 1px solid #21262d;
            letter-spacing: 0.5px;
        }
        .ov-title-bar strong { color: #e6edf3; font-size: 1.2em; }
        .ov-svg-layer {
            position: absolute;
            top: 0; left: 0;
            pointer-events: none;
            z-index: 1;
        }
        .ov-svg-layer line, .ov-svg-layer path {
            fill: none;
            stroke-width: 2;
        }
        .ov-edge-flow { stroke: #3498db; }
        .ov-edge-branch { stroke: #e74c3c; stroke-dasharray: 6 4; }
        .ov-edge-loop { stroke: #f0883e; stroke-dasharray: 6 4; }
        .ov-edge-invoke { stroke: #8b949e; stroke-width: 1.5; }
        .ov-edge-label {
            font-size: 10px;
            fill: #8b949e;
            font-family: 'SF Mono', monospace;
        }
        .ov-edge-label-bg {
            fill: rgba(13,17,23,0.85);
            rx: 3;
        }
        .ov-node {
            position: absolute;
            z-index: 5;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85em;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: box-shadow 0.15s, transform 0.1s;
            text-align: center;
            line-height: 1.2;
            padding: 4px 8px;
        }
        .ov-node:hover {
            transform: scale(1.04);
            box-shadow: 0 0 12px rgba(88,166,255,0.25);
        }
        .ov-node-step {
            background: #2d333b;
            border: 2px solid #484f58;
            color: #e6edf3;
        }
        .ov-node-gate {
            background: #2d333b;
            border: 2px solid #f1c40f;
            color: #f1c40f;
            border-radius: 4px;
            transform: rotate(0deg);
            clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
            font-size: 0.75em;
        }
        .ov-node-gate:hover { transform: scale(1.04); clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%); }
        .ov-node-agent {
            background: rgba(78,205,196,0.12);
            border: 2px solid #4ecdc4;
            color: #4ecdc4;
        }
        .ov-node-tool {
            background: rgba(243,156,18,0.12);
            border: 2px solid #f39c12;
            color: #f39c12;
        }
        .ov-node-store {
            background: rgba(149,165,166,0.12);
            border: 2px solid #95a5a6;
            color: #95a5a6;
        }
        .ov-node-human {
            background: rgba(126,231,135,0.12);
            border: 2px solid #7ee787;
            color: #7ee787;
        }
        .ov-node-entry {
            box-shadow: 0 0 0 3px #7ee787, 0 0 12px rgba(126,231,135,0.3);
        }
        .ov-legend {
            display: flex;
            gap: 16px;
            padding: 8px 20px;
            background: rgba(13,17,23,0.95);
            border-bottom: 1px solid #21262d;
            flex-wrap: wrap;
            align-items: center;
            font-size: 0.75em;
            color: #8b949e;
        }
        .ov-legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .ov-legend-swatch {
            width: 14px;
            height: 14px;
            border-radius: 4px;
        }
        .ov-legend-line {
            width: 20px;
            height: 2px;
        }

        /* Trace file input hidden */
        #trace-file-input { display: none; }
    </style>
</head>
<body>
    <div id="canvas-wrap">
        <div id="header">
            <h1>Open<span>Claw</span> Spec Viewer</h1>
            <select id="spec-select">
                <option value="specs/claude-code.yaml">Claude Code</option>
                <option value="specs/babyagi.yaml">BabyAGI</option>
                <option value="specs/react.yaml">ReAct</option>
                <option value="specs/rag.yaml">RAG</option>
                <option value="specs/autogpt.yaml">AutoGPT</option>
                <option value="specs/crew.yaml">CrewAI</option>
                <option value="specs/code_reviewer.yaml">Code Reviewer</option>
                <option value="specs/babyagi_autogen.yaml">BabyAGI (auto)</option>
                <option value="specs/debate.yaml">Debate</option>
                <option value="specs/tree_of_thought.yaml">Tree of Thought</option>
                <option value="specs/plan_and_solve.yaml">Plan and Solve</option>
                <option value="specs/self_refine.yaml">Self Refine</option>
                <option value="specs/voyager.yaml">Voyager</option>
                <option value="specs/lats.yaml">LATS</option>
                <option value="specs/multi_agent_codegen.yaml">Multi-Agent Codegen</option>
                <option value="specs/map_reduce.yaml">MapReduce</option>
                <option value="specs/socratic_tutor.yaml">Socratic Tutor</option>
                <option value="specs/reflexion.yaml">Reflexion</option>
                <option value="specs/mixture_of_agents.yaml">Mixture of Agents</option>
                <option value="specs/meta_prompting.yaml">Meta Prompting</option>
                <option value="specs/customer_support_swarm.yaml">Customer Support Swarm</option>
                <option value="specs/software_team.yaml">Software Team</option>
            </select>
            <div class="tab-bar">
                <button class="tab-btn active" data-view="graph">Graph</button>
                <button class="tab-btn" data-view="overview">Overview</button>
                <button class="tab-btn" data-view="sm">State Machine</button>
                <button class="tab-btn" data-view="schemas">Schemas</button>
                <button class="tab-btn" data-view="compare">Compare All</button>
            </div>
            <div class="trace-controls" id="trace-controls" style="display:none;">
                <button class="hdr-btn" id="trace-load-btn" title="Load a trace.json file to overlay execution data">Load Trace</button>
                <button class="hdr-btn" id="trace-clear-btn" style="display:none;" title="Clear trace overlay">Clear Trace</button>
                <span class="trace-label" id="trace-info"></span>
            </div>
            <input type="file" id="trace-file-input" accept=".json">
            <span class="stats" id="stats"></span>
        </div>
        <!-- Graph view (existing) -->
        <div id="graph-view" class="view-container active" style="position:absolute;top:0;left:0;right:0;bottom:0;">
            <canvas id="canvas"></canvas>
            <div id="tooltip"></div>
            <div id="legend"></div>
        </div>
        <!-- Overview view -->
        <div id="overview-view" class="view-container"></div>
        <!-- State Machine view -->
        <div id="sm-view" class="view-container"></div>
        <!-- Schemas view -->
        <div id="schemas-view" class="view-container"></div>
        <!-- Compare view -->
        <div id="compare-view" class="view-container"></div>
    </div>
    <div id="sidebar">
        <div style="color:#484f58;font-size:0.8em;padding-top:20px;">Click a node or edge to inspect</div>
    </div>

<script>
// =====================================================================
// Agent Ontology Spec Viewer -- renders agent specs as flowchart diagrams
// =====================================================================

// -- Visual constants from ontology --
const NODE_COLORS = {
    agent:  '#4ecdc4',
    store:  '#95a5a6',
    tool:   '#f39c12',
    human:  '#e6edf3',
    config: '#34495e',
    channel:      '#1abc9c',
    team:         '#2980b9',
    conversation: '#16a085',
    step:       '#3498db',
    gate:       '#f1c40f',
    checkpoint: '#e67e22',
    spawn:      '#9b59b6',
    protocol:   '#3498db',
    policy:     '#e67e22',
    error_handler: '#c0392b',
};

const EDGE_COLORS = {
    flow:      '#3498db',
    invoke:    '#4ecdc4',
    loop:      '#f0883e',
    branch:    '#e74c3c',
    read:      '#2ecc71',
    write:     '#e74c3c',
    modify:    '#e67e22',
    observe:   '#95a5a6',
    error:     '#c0392b',
    publish:   '#1abc9c',
    subscribe: '#1abc9c',
    handoff:   '#8e44ad',
};

const EDGE_STYLES = {
    flow:      'solid',
    invoke:    'solid',
    loop:      'dashed',
    branch:    'dashed',
    read:      'dotted',
    write:     'dotted',
    modify:    'dashed',
    observe:   'dotted',
    error:     'dashed',
    publish:   'solid',
    subscribe: 'solid',
    handoff:   'solid',
};

// -- State --
let spec = null;
let nodes = [];
let edges = [];
let hoverNode = null;
let hoverEdge = null;
let selectedNode = null;
let panX = 0, panY = 0, zoom = 1;
let dragPan = false, dragNodeTarget = null, didDrag = false, lastMX = 0, lastMY = 0;
let traceData = null;

// -- Load spec --
async function loadSpec(path) {
    const resp = await fetch(path + (path.includes('?') ? '&' : '?') + '_t=' + Date.now());
    const text = await resp.text();
    spec = jsyaml.load(text);

    buildGraph();
    layoutGraph();
    drawLegend();
    updateStats();
    selectedNode = null;
    renderSidebar();
    draw();

    if (currentView === 'sm') renderStateMachine();
    if (currentView === 'schemas') renderSchemas();
}

// -- Build graph from spec --
function buildGraph() {
    nodes = [];
    edges = [];
    const idMap = {};

    (spec.entities || []).forEach(e => {
        const n = {
            id: e.id,
            label: e.label || e.id,
            type: e.type,
            category: 'entity',
            data: e,
            x: 0, y: 0, w: 0, h: 0
        };
        nodes.push(n);
        idMap[e.id] = n;
    });

    (spec.processes || []).forEach(p => {
        const n = {
            id: p.id,
            label: p.label || p.id,
            type: p.type,
            category: 'process',
            data: p,
            x: 0, y: 0, w: 0, h: 0
        };
        nodes.push(n);
        idMap[p.id] = n;
    });

    (spec.edges || []).forEach(e => {
        const fromNode = idMap[e.from];
        const toNode = idMap[e.to];
        if (!fromNode || !toNode) return;
        edges.push({
            from: e.from,
            to: e.to,
            type: e.type,
            label: e.label || '',
            data: e,
            fromNode,
            toNode
        });
    });
}

// -- Layout algorithm --
function layoutGraph() {
    const canvas = document.getElementById('canvas');
    const W = canvas.width, H = canvas.height;

    const spine = [];
    const visited = new Set();
    const spineSet = new Set();

    function walkSpine(startId) {
        const queue = [startId];
        while (queue.length > 0) {
            const id = queue.shift();
            if (visited.has(id)) continue;
            const node = nodes.find(n => n.id === id);
            if (!node || node.category !== 'process') continue;
            visited.add(id);
            spine.push(node);
            spineSet.add(id);

            const outgoing = edges.filter(e =>
                e.from === id && (e.type === 'flow' || e.type === 'branch') && e.toNode.category === 'process'
            );
            outgoing.sort((a, b) => {
                if (a.type === 'flow' && b.type === 'branch') return -1;
                if (a.type === 'branch' && b.type === 'flow') return 1;
                return 0;
            });
            for (const e of outgoing) {
                if (!visited.has(e.to)) queue.push(e.to);
            }
        }
    }

    walkSpine(spec.entry_point || (spec.processes && spec.processes[0]?.id));

    nodes.filter(n => n.category === 'process' && !spineSet.has(n.id)).forEach(n => {
        spine.push(n);
        spineSet.add(n.id);
    });

    const ctx = canvas.getContext('2d');
    ctx.font = '12px monospace';

    for (const n of nodes) {
        const textW = ctx.measureText(n.label).width;
        if (n.type === 'gate') {
            n.w = Math.max(textW + 40, 120);
            n.h = 50;
        } else if (n.category === 'entity') {
            n.w = Math.max(textW + 24, 100);
            n.h = 34;
        } else {
            n.w = Math.max(textW + 30, 130);
            n.h = 40;
        }
    }

    const spineX = 500;
    const startY = 80;
    const gapY = 62;
    spine.forEach((n, i) => {
        n.x = spineX;
        n.y = startY + i * gapY;
    });

    const entityPlaced = new Set();
    const stores = nodes.filter(n => n.type === 'store');
    const storeX = 120;
    let storeY = startY;
    stores.forEach(n => {
        const connEdges = edges.filter(e => (e.to === n.id || e.from === n.id) && (e.type === 'read' || e.type === 'write'));
        if (connEdges.length > 0) {
            const procIds = connEdges.map(e => e.from === n.id ? e.to : e.from);
            const procNodes = procIds.map(id => nodes.find(nn => nn.id === id)).filter(Boolean);
            if (procNodes.length > 0) {
                const avgY = procNodes.reduce((s, p) => s + p.y, 0) / procNodes.length;
                n.y = avgY;
            } else {
                n.y = storeY;
            }
        } else {
            n.y = storeY;
        }
        n.x = storeX;
        storeY = Math.max(storeY, n.y + 50);
        entityPlaced.add(n.id);
    });

    stores.sort((a, b) => a.y - b.y);
    for (let i = 1; i < stores.length; i++) {
        if (stores[i].y - stores[i-1].y < 42) {
            stores[i].y = stores[i-1].y + 42;
        }
    }

    const tools = nodes.filter(n => n.type === 'tool');
    const toolX = 880;
    const toolInvokeProc = edges.filter(e => e.type === 'invoke' && tools.some(t => t.id === e.to));
    const execNode = nodes.find(n => n.id === 'execute');
    const toolBaseY = execNode ? execNode.y - (tools.length * 18) : startY + 200;
    tools.forEach((n, i) => {
        n.x = toolX;
        n.y = toolBaseY + i * 36;
        entityPlaced.add(n.id);
    });

    const agents = nodes.filter(n => n.type === 'agent');
    agents.forEach(n => {
        const invokeEdge = edges.find(e => e.type === 'invoke' && e.to === n.id);
        if (invokeEdge && invokeEdge.fromNode) {
            n.x = invokeEdge.fromNode.x + 280;
            n.y = invokeEdge.fromNode.y;
        } else {
            n.x = toolX + 150;
            n.y = startY;
        }
        entityPlaced.add(n.id);
    });

    const humans = nodes.filter(n => n.type === 'human');
    humans.forEach(n => {
        n.x = 30;
        n.y = startY + 60;
        entityPlaced.add(n.id);
    });

    const configs = nodes.filter(n => n.type === 'config');
    configs.forEach((n, i) => {
        n.x = 40;
        n.y = storeY + 60 + i * 50;
        entityPlaced.add(n.id);
    });

    const policies = nodes.filter(n => n.type === 'policy');
    policies.forEach((n, i) => {
        const modEdge = edges.find(e => e.from === n.id && (e.type === 'modify' || e.type === 'observe'));
        if (modEdge && modEdge.toNode) {
            n.x = modEdge.toNode.x - 220;
            n.y = modEdge.toNode.y + i * 44;
        } else {
            n.x = 280;
            n.y = startY + 400 + i * 50;
        }
    });

    const spawns = nodes.filter(n => n.type === 'spawn');
    spawns.forEach(n => {
        const execN = nodes.find(nn => nn.id === 'execute');
        n.x = (execN ? execN.x : spineX) + 200;
        n.y = (execN ? execN.y : startY) + 50;
    });

    const allX = nodes.map(n => n.x);
    const allY = nodes.map(n => n.y);
    const minX = Math.min(...allX) - 80;
    const maxX = Math.max(...allX) + 200;
    const maxY = Math.max(...allY) + 80;
    const minY = Math.min(...allY) - 60;

    panX = (W / 2) - ((minX + maxX) / 2);
    panY = 20 - minY;

    const diagramH = maxY - minY + 100;
    const diagramW = maxX - minX + 100;
    if (diagramH > H - 60 || diagramW > W) {
        zoom = Math.min((H - 60) / diagramH, W / diagramW, 1);
        panX = (W / 2) - ((minX + maxX) / 2) * zoom;
        panY = (60 - minY * zoom);
    }
}

// -- Drawing --
function draw() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    ctx.clearRect(0, 0, W, H);
    ctx.save();
    ctx.translate(panX, panY);
    ctx.scale(zoom, zoom);

    for (const e of edges) {
        drawEdge(ctx, e);
    }

    for (const n of nodes) {
        drawNode(ctx, n);
    }

    ctx.restore();
}

function drawNode(ctx, n) {
    const x = n.x, y = n.y, w = n.w, h = n.h;
    const isSel = selectedNode === n;
    const isHov = hoverNode === n;
    const connected = hoverNode && edges.some(e =>
        (e.fromNode === hoverNode && e.toNode === n) || (e.toNode === hoverNode && e.fromNode === n)
    );
    const dimmed = hoverNode && !isHov && !connected;
    const alpha = dimmed ? 0.2 : 1;

    ctx.globalAlpha = alpha;

    if (isSel || isHov) {
        ctx.shadowColor = isSel ? '#58a6ff' : 'rgba(88,166,255,0.4)';
        ctx.shadowBlur = isSel ? 12 : 8;
    }

    const color = NODE_COLORS[n.type] || '#484f58';

    ctx.beginPath();
    if (n.type === 'gate') {
        ctx.moveTo(x, y - h/2);
        ctx.lineTo(x + w/2, y);
        ctx.lineTo(x, y + h/2);
        ctx.lineTo(x - w/2, y);
        ctx.closePath();
    } else if (n.type === 'checkpoint') {
        const s = Math.min(w, h) / 2;
        const d = s * 0.38;
        ctx.moveTo(x - s + d, y - s);
        ctx.lineTo(x + s - d, y - s);
        ctx.lineTo(x + s, y - s + d);
        ctx.lineTo(x + s, y + s - d);
        ctx.lineTo(x + s - d, y + s);
        ctx.lineTo(x - s + d, y + s);
        ctx.lineTo(x - s, y + s - d);
        ctx.lineTo(x - s, y - s + d);
        ctx.closePath();
    } else if (n.type === 'store') {
        const rx = w/2, ry = 6;
        ctx.moveTo(x - rx, y - h/2 + ry);
        ctx.ellipse(x, y - h/2 + ry, rx, ry, 0, Math.PI, 0);
        ctx.lineTo(x + rx, y + h/2 - ry);
        ctx.ellipse(x, y + h/2 - ry, rx, ry, 0, 0, Math.PI);
        ctx.closePath();
    } else if (n.type === 'spawn') {
        const r = 4;
        roundRect(ctx, x - w/2 + 3, y - h/2 + 3, w - 6, h - 6, r);
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.stroke();
        if (n.data.template === 'self' || n.data.recursive) {
            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            const ix = x + w/2 - 14, iy = y - h/2 + 12;
            ctx.arc(ix, iy, 5, -Math.PI * 0.3, Math.PI * 1.3);
            ctx.stroke();
            const ax = ix + 5 * Math.cos(-Math.PI * 0.3);
            const ay = iy + 5 * Math.sin(-Math.PI * 0.3);
            ctx.beginPath();
            ctx.moveTo(ax, ay);
            ctx.lineTo(ax + 3, ay - 3);
            ctx.lineTo(ax - 1, ay - 4);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.restore();
        }
        ctx.beginPath();
        roundRect(ctx, x - w/2, y - h/2, w, h, r);
    } else if (n.type === 'policy') {
        ctx.moveTo(x, y - h/2);
        ctx.lineTo(x + w/2, y - h/2 + 8);
        ctx.lineTo(x + w/2, y + h/4);
        ctx.quadraticCurveTo(x, y + h/2 + 4, x, y + h/2);
        ctx.quadraticCurveTo(x, y + h/2 + 4, x - w/2, y + h/4);
        ctx.lineTo(x - w/2, y - h/2 + 8);
        ctx.closePath();
    } else if (n.type === 'tool') {
        roundRect(ctx, x - w/2, y - h/2, w, h, 4);
    } else if (n.category === 'entity') {
        roundRect(ctx, x - w/2, y - h/2, w, h, 8);
    } else {
        roundRect(ctx, x - w/2, y - h/2, w, h, 4);
    }

    if (n.category === 'process') {
        ctx.fillStyle = isSel ? '#2d333b' : '#1c2028';
    } else {
        ctx.fillStyle = isSel ? color : adjustAlpha(color, 0.15);
    }
    ctx.fill();

    ctx.strokeStyle = isSel ? '#58a6ff' : color;
    ctx.lineWidth = isSel ? 2 : (n.category === 'process' ? 1.5 : 1);
    ctx.stroke();

    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;

    if (n.type === 'store') {
        const rx = w/2, ry = 6;
        ctx.beginPath();
        ctx.ellipse(x, y - h/2 + ry, rx, ry, 0, 0, Math.PI * 2);
        ctx.fillStyle = isSel ? '#2d333b' : '#1c2028';
        ctx.fill();
        ctx.strokeStyle = isSel ? '#58a6ff' : color;
        ctx.lineWidth = isSel ? 2 : 1;
        ctx.stroke();
    }

    ctx.font = (isHov || isSel) ? 'bold 11px monospace' : '11px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = n.category === 'process' ? color : (isSel ? '#fff' : color);
    const maxLabelW = w - 12;
    let label = n.label;
    if (ctx.measureText(label).width > maxLabelW) {
        while (label.length > 3 && ctx.measureText(label + '...').width > maxLabelW) {
            label = label.slice(0, -1);
        }
        label += '...';
    }
    ctx.fillText(label, x, y);

    ctx.globalAlpha = 1;
}

function drawEdge(ctx, e) {
    const from = e.fromNode, to = e.toNode;
    const isHighlighted = hoverNode && (from === hoverNode || to === hoverNode);
    const isHovered = hoverEdge === e;
    const dimmed = hoverNode && !isHighlighted;

    const color = (isHighlighted || isHovered) ? '#58a6ff' : (EDGE_COLORS[e.type] || '#21262d');
    const style = EDGE_STYLES[e.type] || 'solid';

    ctx.globalAlpha = dimmed ? 0.08 : (isHighlighted || isHovered ? 1 : 0.6);

    const [x1, y1] = getEdgeAnchor(from, to);
    const [x2, y2] = getEdgeAnchor(to, from);

    if (e.type === 'loop') {
        drawLoopEdge(ctx, e, x1, y1, x2, y2, color);
        ctx.globalAlpha = 1;
        return;
    }

    ctx.strokeStyle = color;
    ctx.lineWidth = (isHighlighted || isHovered) ? 2 : 1;
    setLineDash(ctx, style);

    const dx = x2 - x1, dy = y2 - y1;
    const dist = Math.sqrt(dx*dx + dy*dy);
    let cx = (x1+x2)/2, cy = (y1+y2)/2;

    if (from.x !== to.x || dist > 200) {
        cx -= dy * 0.08;
        cy += dx * 0.08;
    }

    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.quadraticCurveTo(cx, cy, x2, y2);
    ctx.stroke();
    ctx.setLineDash([]);

    const angle = Math.atan2(y2 - cy, x2 - cx);
    drawArrowhead(ctx, x2, y2, angle, color);

    if ((isHighlighted || isHovered) && e.label) {
        const lx = (x1 + cx + x2) / 3;
        const ly = (y1 + cy + y2) / 3 - 8;
        ctx.font = '9px monospace';
        ctx.fillStyle = '#8b949e';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';

        const tw = ctx.measureText(e.label).width + 8;
        ctx.fillStyle = 'rgba(13,17,23,0.85)';
        ctx.fillRect(lx - tw/2, ly - 10, tw, 13);
        ctx.fillStyle = (isHighlighted || isHovered) ? '#c9d1d9' : '#8b949e';
        ctx.fillText(e.label, lx, ly);
    }

    ctx.globalAlpha = 1;
}

function drawLoopEdge(ctx, e, x1, y1, x2, y2, color) {
    const from = e.fromNode, to = e.toNode;
    const isRight = from.x >= to.x;
    const offsetX = isRight ? 100 : -100;

    const midY = (y1 + y2) / 2;

    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    setLineDash(ctx, 'dashed');

    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.bezierCurveTo(
        x1 + offsetX, y1,
        x2 + offsetX, y2,
        x2, y2
    );
    ctx.stroke();
    ctx.setLineDash([]);

    const angle = Math.atan2(y2 - (y2 - 30), x2 - (x2 + offsetX * 0.3));
    drawArrowhead(ctx, x2, y2, angle, color);

    if (e.label) {
        ctx.font = 'bold 10px monospace';
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.fillText(e.label, Math.max(x1, x2) + offsetX * 0.6, midY);
    }
}

function drawArrowhead(ctx, x, y, angle, color) {
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x - Math.cos(angle - 0.4) * 8, y - Math.sin(angle - 0.4) * 8);
    ctx.lineTo(x - Math.cos(angle + 0.4) * 8, y - Math.sin(angle + 0.4) * 8);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
}

function getEdgeAnchor(from, to) {
    const dx = to.x - from.x;
    const dy = to.y - from.y;
    const angle = Math.atan2(dy, dx);

    if (from.type === 'gate') {
        const hw = from.w / 2, hh = from.h / 2;
        const absA = Math.abs(angle);
        if (absA < Math.atan2(hh, hw) || absA > Math.PI - Math.atan2(hh, hw)) {
            const sx = Math.sign(dx);
            return [from.x + sx * hw, from.y + (dy/Math.abs(dx)) * hw * Math.sign(dx) * 0.5];
        } else {
            const sy = Math.sign(dy);
            return [from.x + (dx/Math.abs(dy)) * hh * Math.sign(dy) * 0.5, from.y + sy * hh];
        }
    }

    const hw = from.w / 2 + 1, hh = from.h / 2 + 1;
    const tanA = Math.abs(dy / (dx || 0.001));
    if (tanA < hh / hw) {
        const sx = Math.sign(dx) || 1;
        return [from.x + sx * hw, from.y + (dy * hw / Math.abs(dx || 0.001)) * sx * 0.5];
    } else {
        const sy = Math.sign(dy) || 1;
        return [from.x + (dx * hh / Math.abs(dy || 0.001)) * sy * 0.5, from.y + sy * hh];
    }
}

function setLineDash(ctx, style) {
    if (style === 'dashed') ctx.setLineDash([6, 4]);
    else if (style === 'dotted') ctx.setLineDash([2, 3]);
    else ctx.setLineDash([]);
}

function roundRect(ctx, x, y, w, h, r) {
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
}

function adjustAlpha(hex, alpha) {
    const r = parseInt(hex.slice(1,3), 16);
    const g = parseInt(hex.slice(3,5), 16);
    const b = parseInt(hex.slice(5,7), 16);
    return `rgba(${r},${g},${b},${alpha})`;
}

// -- Interaction --
function initInteraction() {
    const canvas = document.getElementById('canvas');
    const wrap = document.getElementById('canvas-wrap');

    function resize() {
        canvas.width = wrap.clientWidth;
        canvas.height = wrap.clientHeight;
        if (spec && currentView === 'graph') {
            layoutGraph();
            draw();
        }
    }
    window.addEventListener('resize', resize);
    resize();

    canvas.addEventListener('wheel', (ev) => {
        ev.preventDefault();
        const factor = ev.deltaY > 0 ? 0.92 : 1.08;
        const rect = canvas.getBoundingClientRect();
        const mx = (ev.clientX - rect.left);
        const my = (ev.clientY - rect.top);

        panX = mx - (mx - panX) * factor;
        panY = my - (my - panY) * factor;
        zoom *= factor;
        zoom = Math.max(0.15, Math.min(3, zoom));
        draw();
    }, { passive: false });

    canvas.addEventListener('mousedown', (ev) => {
        if (ev.button !== 0) return;
        lastMX = ev.clientX;
        lastMY = ev.clientY;
        didDrag = false;

        const [mx, my] = canvasToGraph(ev);
        const hitNode = findNodeAt(mx, my);
        if (hitNode) {
            dragNodeTarget = hitNode;
            canvas.style.cursor = 'grabbing';
        } else {
            dragPan = true;
            canvas.style.cursor = 'grabbing';
        }
    });

    canvas.addEventListener('mousemove', (ev) => {
        const dxScreen = ev.clientX - lastMX;
        const dyScreen = ev.clientY - lastMY;

        if (dragNodeTarget) {
            dragNodeTarget.x += dxScreen / zoom;
            dragNodeTarget.y += dyScreen / zoom;
            lastMX = ev.clientX;
            lastMY = ev.clientY;
            if (Math.abs(dxScreen) > 2 || Math.abs(dyScreen) > 2) didDrag = true;
            document.getElementById('tooltip').style.display = 'none';
            draw();
            return;
        }

        if (dragPan) {
            panX += dxScreen;
            panY += dyScreen;
            lastMX = ev.clientX;
            lastMY = ev.clientY;
            if (Math.abs(dxScreen) > 2 || Math.abs(dyScreen) > 2) didDrag = true;
            draw();
            return;
        }

        const [mx, my] = canvasToGraph(ev);
        const prevHover = hoverNode;
        hoverNode = findNodeAt(mx, my);
        hoverEdge = !hoverNode ? findEdgeAt(mx, my) : null;

        canvas.style.cursor = hoverNode ? 'grab' : (hoverEdge ? 'pointer' : 'default');
        if (hoverNode !== prevHover || hoverEdge) {
            draw();
        }
        if (!hoverNode && !hoverEdge) {
            document.getElementById('tooltip').style.display = 'none';
        } else {
            showTooltip(ev, hoverNode, hoverEdge);
        }
    });

    canvas.addEventListener('mouseup', (ev) => {
        const wasDraggingNode = !!dragNodeTarget;
        dragPan = false;
        dragNodeTarget = null;

        if (!didDrag) {
            const [mx, my] = canvasToGraph(ev);
            const clicked = findNodeAt(mx, my);
            if (clicked) {
                selectedNode = clicked;
                renderSidebar();
                draw();
            } else {
                const clickedEdge = findEdgeAt(mx, my);
                if (clickedEdge) {
                    selectedNode = null;
                    renderEdgeSidebar(clickedEdge);
                    draw();
                }
            }
        }

        canvas.style.cursor = (hoverNode) ? 'grab' : (hoverEdge ? 'pointer' : 'default');
    });

    canvas.addEventListener('mouseleave', () => {
        dragPan = false;
        dragNodeTarget = null;
        hoverNode = null;
        hoverEdge = null;
        document.getElementById('tooltip').style.display = 'none';
        draw();
    });
}

function canvasToGraph(ev) {
    const canvas = document.getElementById('canvas');
    const rect = canvas.getBoundingClientRect();
    const cx = (ev.clientX - rect.left);
    const cy = (ev.clientY - rect.top);
    return [(cx - panX) / zoom, (cy - panY) / zoom];
}

function findNodeAt(mx, my) {
    for (let i = nodes.length - 1; i >= 0; i--) {
        const n = nodes[i];
        if (mx >= n.x - n.w/2 && mx <= n.x + n.w/2 && my >= n.y - n.h/2 && my <= n.y + n.h/2) {
            return n;
        }
    }
    return null;
}

function findEdgeAt(mx, my) {
    for (const e of edges) {
        const [x1, y1] = getEdgeAnchor(e.fromNode, e.toNode);
        const [x2, y2] = getEdgeAnchor(e.toNode, e.fromNode);
        const dx = x2 - x1, dy = y2 - y1;
        const len2 = dx*dx + dy*dy;
        if (len2 === 0) continue;
        let t = ((mx - x1) * dx + (my - y1) * dy) / len2;
        t = Math.max(0, Math.min(1, t));
        const px = x1 + t * dx, py = y1 + t * dy;
        const dist = Math.sqrt((mx - px)**2 + (my - py)**2);
        if (dist < 10) return e;
    }
    return null;
}

function showTooltip(ev, node, edge) {
    const tt = document.getElementById('tooltip');
    const wrap = document.getElementById('canvas-wrap');
    const rect = wrap.getBoundingClientRect();

    if (node) {
        const color = NODE_COLORS[node.type] || '#484f58';
        const edgeCount = edges.filter(e => e.fromNode === node || e.toNode === node).length;
        const desc = node.data.description || '';
        tt.innerHTML = `
            <div style="color:${color};font-weight:600;font-size:1.1em;margin-bottom:4px;">${node.label}</div>
            <div style="color:#484f58;font-size:0.85em;margin-bottom:4px;">${node.type} (${node.category}) &middot; ${edgeCount} edges</div>
            ${desc ? `<div style="color:#8b949e;line-height:1.4;">${desc.substring(0, 200)}${desc.length > 200 ? '...' : ''}</div>` : ''}
            <div style="color:#484f58;font-size:0.85em;margin-top:6px;">Click for details</div>
        `;
    } else if (edge) {
        const color = EDGE_COLORS[edge.type] || '#484f58';
        tt.innerHTML = `
            <div style="color:${color};font-weight:600;font-size:1.05em;margin-bottom:4px;">${edge.label || edge.type}</div>
            <div style="color:#484f58;font-size:0.85em;">${edge.type.toUpperCase()}</div>
            <div style="color:#8b949e;margin-top:4px;">
                ${edge.fromNode.label} <span style="color:#484f58;">&rarr;</span> ${edge.toNode.label}
            </div>
        `;
    }

    tt.style.display = 'block';
    tt.style.left = Math.min(ev.clientX - rect.left + 14, rect.width - 370) + 'px';
    tt.style.top = (ev.clientY - rect.top + 14) + 'px';
}

// -- Sidebar --
function renderSidebar() {
    const sb = document.getElementById('sidebar');
    if (!selectedNode) {
        sb.innerHTML = '<div style="color:#484f58;font-size:0.8em;padding-top:70px;">Click a node or edge to inspect</div>';
        return;
    }

    const n = selectedNode;
    const d = n.data;
    const color = NODE_COLORS[n.type] || '#484f58';

    let html = `
        <div class="sb-title" style="color:${color}">${n.label}</div>
        <div class="sb-type">${n.type} &middot; ${n.category}</div>
    `;

    if (d.description) {
        html += `<div class="sb-desc">${d.description}</div>`;
    }

    if (d.subgraph === 'self' || d.template === 'self' || d.recursive) {
        html += `<div style="background:rgba(155,89,182,0.15);border:1px solid #9b59b6;border-radius:4px;padding:8px;margin-bottom:12px;font-size:0.8em;">
            <span style="color:#9b59b6;font-weight:600;">&#x21bb; Recursive</span>
            <span style="color:#8b949e;"> -- this ${d.subgraph === 'self' ? 'agent runs the same architecture' : 'spawns instances of the parent spec'}.
            Depth bounded by ${d.max_depth && d.max_depth !== 'unbounded' ? 'max_depth=' + d.max_depth : 'context window / cost'}.</span>
        </div>`;
    }

    // Logic section
    if (d.logic) {
        html += `<div class="sb-section">Logic</div>`;
        html += `<div class="sb-logic">${escapeHtml(d.logic)}</div>`;
    }

    const skip = new Set(['id', 'type', 'label', 'description', 'logic']);
    const props = Object.entries(d).filter(([k]) => !skip.has(k));
    if (props.length > 0) {
        html += `<div class="sb-section">Properties</div>`;
        for (const [key, val] of props) {
            if (key === 'branches' && Array.isArray(val)) {
                html += `<div class="sb-section">Branches</div>`;
                for (const b of val) {
                    const tgt = nodes.find(nn => nn.id === b.target);
                    html += `<div class="sb-field"><span class="key">${b.condition}</span><span class="val">${tgt ? tgt.label : b.target}</span></div>`;
                }
            } else {
                const display = typeof val === 'object' ? JSON.stringify(val, null, 1).substring(0, 200) : String(val);
                html += `<div class="sb-field"><span class="key">${key}</span><span class="val">${display}</span></div>`;
            }
        }
    }

    const outgoing = edges.filter(e => e.fromNode === n);
    const incoming = edges.filter(e => e.toNode === n);

    if (outgoing.length > 0) {
        html += `<div class="sb-section">Outgoing Edges (${outgoing.length})</div>`;
        for (const e of outgoing) {
            html += `<div class="sb-edge" style="border-color:${EDGE_COLORS[e.type]}" onclick="selectEdgeTarget('${e.to}')">
                <div class="edge-label">${e.label || e.type}</div>
                <div class="edge-detail">${e.type} &rarr; ${e.toNode.label}</div>
            </div>`;
        }
    }

    if (incoming.length > 0) {
        html += `<div class="sb-section">Incoming Edges (${incoming.length})</div>`;
        for (const e of incoming) {
            html += `<div class="sb-edge" style="border-color:${EDGE_COLORS[e.type]}" onclick="selectEdgeTarget('${e.from}')">
                <div class="edge-label">${e.label || e.type}</div>
                <div class="edge-detail">${e.fromNode.label} &rarr; ${e.type}</div>
            </div>`;
        }
    }

    const schemaRefs = new Set();
    if (d.input_schema) schemaRefs.add(d.input_schema);
    if (d.output_schema) schemaRefs.add(d.output_schema);
    if (d.data_in) schemaRefs.add(d.data_in);
    if (d.data_out) schemaRefs.add(d.data_out);
    if (d.schema) schemaRefs.add(d.schema);

    if (schemaRefs.size > 0 && spec.schemas) {
        html += `<div class="sb-section">Schemas</div>`;
        for (const ref of schemaRefs) {
            const schema = spec.schemas.find(s => s.name === ref);
            if (schema) {
                html += `<div class="sb-schema">
                    <div style="color:#58a6ff;font-weight:600;margin-bottom:4px;">${schema.name}</div>
                    ${schema.description ? `<div style="color:#484f58;margin-bottom:4px;">${schema.description}</div>` : ''}
                    ${(schema.fields || []).map(f =>
                        `<div><span class="field-name">${f.name}</span>: <span class="field-type">${f.type}</span></div>`
                    ).join('')}
                </div>`;
            }
        }
    }

    sb.innerHTML = html;
}

function renderEdgeSidebar(e) {
    const sb = document.getElementById('sidebar');
    const color = EDGE_COLORS[e.type] || '#484f58';

    let html = `
        <div class="sb-title" style="color:${color}">${e.label || e.type}</div>
        <div class="sb-type">${e.type} edge</div>
        <div class="sb-section">Connection</div>
        <div class="sb-field"><span class="key">From</span><span class="val" style="cursor:pointer;color:${NODE_COLORS[e.fromNode.type]}" onclick="selectEdgeTarget('${e.from}')">${e.fromNode.label}</span></div>
        <div class="sb-field"><span class="key">To</span><span class="val" style="cursor:pointer;color:${NODE_COLORS[e.toNode.type]}" onclick="selectEdgeTarget('${e.to}')">${e.toNode.label}</span></div>
    `;

    const skip = new Set(['from', 'to', 'type', 'label']);
    const props = Object.entries(e.data).filter(([k]) => !skip.has(k));
    if (props.length > 0) {
        html += `<div class="sb-section">Properties</div>`;
        for (const [key, val] of props) {
            const display = typeof val === 'object' ? JSON.stringify(val) : String(val);
            html += `<div class="sb-field"><span class="key">${key}</span><span class="val">${display}</span></div>`;
        }
    }

    const schemaRef = e.data.data || e.data.input || e.data.output;
    if (schemaRef && spec.schemas) {
        const schema = spec.schemas.find(s => s.name === schemaRef);
        if (schema) {
            html += `<div class="sb-section">Data Schema</div>
                <div class="sb-schema">
                    <div style="color:#58a6ff;font-weight:600;margin-bottom:4px;">${schema.name}</div>
                    ${(schema.fields || []).map(f =>
                        `<div><span class="field-name">${f.name}</span>: <span class="field-type">${f.type}</span></div>`
                    ).join('')}
                </div>`;
        }
    }

    sb.innerHTML = html;
}

function selectEdgeTarget(id) {
    const n = nodes.find(n => n.id === id);
    if (n) {
        selectedNode = n;
        renderSidebar();
        draw();
    }
}

// -- Legend --
function drawLegend() {
    const leg = document.getElementById('legend');
    const types = [
        ['Step', NODE_COLORS.step], ['Gate', NODE_COLORS.gate],
        ['Checkpoint', NODE_COLORS.checkpoint], ['Agent', NODE_COLORS.agent],
        ['Store', NODE_COLORS.store], ['Tool', NODE_COLORS.tool],
        ['Policy', NODE_COLORS.policy], ['Spawn', NODE_COLORS.spawn],
        ['Channel', NODE_COLORS.channel], ['Team', NODE_COLORS.team],
        ['Conversation', NODE_COLORS.conversation],
    ];
    leg.innerHTML = types.map(([name, color]) =>
        `<div class="legend-item"><div class="legend-swatch" style="background:${color}"></div>${name}</div>`
    ).join('');
}

function updateStats() {
    const el = document.getElementById('stats');
    el.textContent = `${nodes.filter(n => n.category === 'entity').length} entities \u00b7 ${nodes.filter(n => n.category === 'process').length} processes \u00b7 ${edges.length} edges \u00b7 ${(spec.schemas||[]).length} schemas`;
}

function escapeHtml(str) {
    return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

// =====================================================================
// View switching
// =====================================================================

let currentView = 'graph';

function switchView(view) {
    currentView = view;
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b.dataset.view === view));
    document.querySelectorAll('.view-container').forEach(v => v.classList.remove('active'));
    const viewIds = { graph: 'graph-view', overview: 'overview-view', sm: 'sm-view', schemas: 'schemas-view', compare: 'compare-view' };
    document.getElementById(viewIds[view]).classList.add('active');

    const sidebar = document.getElementById('sidebar');
    const traceControls = document.getElementById('trace-controls');

    if (view === 'graph') {
        sidebar.style.display = '';
        traceControls.style.display = 'none';
        const canvas = document.getElementById('canvas');
        const wrap = document.getElementById('canvas-wrap');
        canvas.width = wrap.clientWidth;
        canvas.height = wrap.clientHeight;
        layoutGraph();
        draw();
    } else {
        sidebar.style.display = '';
        traceControls.style.display = (view === 'sm') ? 'flex' : 'none';
        if (view === 'compare' || view === 'overview') {
            sidebar.style.display = 'none';
        }
        if (view === 'overview') renderOverview();
        if (view === 'sm') renderStateMachine();
        if (view === 'schemas') renderSchemas();
        if (view === 'compare') renderComparison();
    }
}

// =====================================================================
// Overview View (simplified diagram with step+agent collapsing)
// =====================================================================

function renderOverview() {
    if (!spec) return;
    const container = document.getElementById('overview-view');
    const processes = spec.processes || [];
    const specEdges = spec.edges || [];
    const entities = spec.entities || [];
    const entityMap = {};
    for (const e of entities) entityMap[e.id] = e;

    // Classify edges by type
    const flowTo = {};
    const branchTo = {};
    const loopsTo = {};
    const procInvokes = {};   // procId -> [{entityId, label}] (agent/tool invokes)
    const procWrites = {};    // procId -> [{entityId, label}] (store writes)
    const procReads = {};     // procId -> [{entityId, label}] (store reads)

    for (const e of specEdges) {
        const fromProc = processes.find(p => p.id === e.from);
        const toProc = processes.find(p => p.id === e.to);
        const toEnt = entityMap[e.to];

        if (e.type === 'flow' && fromProc && toProc) {
            if (!flowTo[e.from]) flowTo[e.from] = [];
            flowTo[e.from].push({ target: e.to, label: e.label || '' });
        }
        if (e.type === 'branch' && fromProc && toProc) {
            if (!branchTo[e.from]) branchTo[e.from] = [];
            branchTo[e.from].push({ target: e.to, label: e.label || '', condition: e.condition || '' });
        }
        if (e.type === 'loop' && fromProc && toProc) {
            loopsTo[e.from] = { target: e.to, label: e.label || '', condition: e.condition || '' };
        }
        if (e.type === 'invoke' && fromProc && toEnt) {
            if (!procInvokes[e.from]) procInvokes[e.from] = [];
            procInvokes[e.from].push({ entityId: e.to, label: e.label || '', type: toEnt.type, output: e.output || '' });
        }
        if (e.type === 'write' && fromProc && toEnt) {
            if (!procWrites[e.from]) procWrites[e.from] = [];
            procWrites[e.from].push({ entityId: e.to, label: e.label || '' });
        }
        if (e.type === 'read' && fromProc && toEnt) {
            if (!procReads[e.from]) procReads[e.from] = [];
            // Return label: use edge's data field, or fall back to the store's schema
            const returnSchema = e.data || e.query || toEnt.schema || '';
            procReads[e.from].push({ entityId: e.to, label: e.label || '', returnLabel: returnSchema });
        }
    }

    // Determine which steps collapse with their single invoked agent.
    // Rule: step has NO logic, invokes exactly 1 agent, has no write edges → collapse.
    // Steps with logic do real work beyond just invoking, so keep them separate.
    const collapsed = {};  // procId -> entityId (the agent it collapses with)
    for (const proc of processes) {
        if (proc.type !== 'step') continue;
        if (proc.logic) continue;  // has real work, don't collapse
        const invokes = procInvokes[proc.id] || [];
        const writes = procWrites[proc.id] || [];
        const reads = procReads[proc.id] || [];
        if (invokes.length === 1 && writes.length === 0 && reads.length === 0 && invokes[0].type === 'agent') {
            collapsed[proc.id] = invokes[0].entityId;
        }
    }

    // BFS spine from entry point
    const entryId = spec.entry_point || (processes[0] && processes[0].id);
    const spine = [];
    const visited = new Set();
    const queue = [entryId];
    while (queue.length > 0) {
        const id = queue.shift();
        if (visited.has(id)) continue;
        const proc = processes.find(p => p.id === id);
        if (!proc) continue;
        visited.add(id);
        spine.push(proc);
        const flows = (flowTo[id] || []).map(f => f.target);
        const branches = (branchTo[id] || []).map(b => b.target);
        const procBranches = (proc.branches || []).map(b => b.target);
        for (const t of [...flows, ...branches, ...procBranches]) {
            if (!visited.has(t)) queue.push(t);
        }
    }
    for (const p of processes) {
        if (!visited.has(p.id)) { spine.push(p); visited.add(p.id); }
    }

    // Build the display nodes: collapsed agent nodes replace their step,
    // uncollapsed steps keep separate entity boxes for multi-invoke/writes.
    // Each display node: {id, label, type: 'step'|'gate'|'agent'|'checkpoint'|'spawn', procId, entityId?}
    const displayNodes = [];
    const collapsedEntities = new Set(Object.values(collapsed));

    for (const proc of spine) {
        if (collapsed[proc.id]) {
            const ent = entityMap[collapsed[proc.id]];
            displayNodes.push({
                id: proc.id,
                label: ent ? (ent.label || ent.id) : proc.label || proc.id,
                type: 'agent',
                procId: proc.id,
                entityId: collapsed[proc.id]
            });
        } else {
            displayNodes.push({
                id: proc.id,
                label: proc.label || proc.id,
                type: proc.type || 'step',
                procId: proc.id
            });
        }
    }

    // Collect uncollapsed entities that need their own box
    // (entities invoked/written by non-collapsed steps, excluding already-collapsed agents)
    const sideEntities = {};  // entityId -> {id, label, type, usedBy: [{procId, edgeLabel}]}
    for (const proc of spine) {
        if (collapsed[proc.id]) continue;  // collapsed steps don't show separate entities
        const invokes = (procInvokes[proc.id] || []);
        const writes = (procWrites[proc.id] || []);
        const reads = (procReads[proc.id] || []);
        for (const inv of invokes) {
            if (collapsedEntities.has(inv.entityId)) continue;
            if (!sideEntities[inv.entityId]) {
                const ent = entityMap[inv.entityId];
                sideEntities[inv.entityId] = {
                    id: inv.entityId,
                    label: ent ? (ent.label || inv.entityId) : inv.entityId,
                    type: ent ? ent.type : 'agent',
                    usedBy: []
                };
            }
            sideEntities[inv.entityId].usedBy.push({ procId: proc.id, edgeType: 'invoke', edgeLabel: inv.label, returnLabel: inv.output || '' });
        }
        for (const wr of writes) {
            if (!sideEntities[wr.entityId]) {
                const ent = entityMap[wr.entityId];
                sideEntities[wr.entityId] = {
                    id: wr.entityId,
                    label: ent ? (ent.label || wr.entityId) : wr.entityId,
                    type: ent ? ent.type : 'store',
                    usedBy: []
                };
            }
            sideEntities[wr.entityId].usedBy.push({ procId: proc.id, edgeType: 'write', edgeLabel: wr.label });
        }
        for (const rd of reads) {
            if (!sideEntities[rd.entityId]) {
                const ent = entityMap[rd.entityId];
                sideEntities[rd.entityId] = {
                    id: rd.entityId,
                    label: ent ? (ent.label || rd.entityId) : rd.entityId,
                    type: ent ? ent.type : 'store',
                    usedBy: []
                };
            }
            sideEntities[rd.entityId].usedBy.push({ procId: proc.id, edgeType: 'read', edgeLabel: rd.label, returnLabel: rd.returnLabel });
        }
    }

    // Layout
    const NODE_W = 200, NODE_H = 44, GATE_H = 60;
    const SIDE_W = 150, SIDE_H = 38;
    const GAP_Y = 80;
    const SIDE_OFFSET_X = 80;
    const SPINE_X = 200;
    const PAD_TOP = 20;

    const nodePos = {};  // displayNode.id -> {x, y, w, h}
    let curY = PAD_TOP;
    for (const dn of displayNodes) {
        const h = dn.type === 'gate' ? GATE_H : NODE_H;
        nodePos[dn.id] = { x: SPINE_X, y: curY, w: NODE_W, h };
        curY += h + GAP_Y;
    }

    // Position side entities: place each once, at the average Y of all processes using it
    const sidePos = {};  // entityId -> {x, y, w, h}
    const sideX = SPINE_X + NODE_W + SIDE_OFFSET_X;
    const usedSlots = {};
    for (const [eid, se] of Object.entries(sideEntities)) {
        const procYs = se.usedBy.map(u => nodePos[u.procId]).filter(Boolean).map(p => p.y + p.h / 2);
        const avgY = procYs.length > 0 ? procYs.reduce((a, b) => a + b, 0) / procYs.length : PAD_TOP;
        let slotY = Math.round(avgY - SIDE_H / 2);
        // Avoid overlaps with other side entities
        while (Object.values(usedSlots).some(sy => Math.abs(sy - slotY) < SIDE_H + 8)) {
            slotY += SIDE_H + 8;
        }
        usedSlots[eid] = slotY;
        sidePos[eid] = { x: sideX, y: slotY, w: SIDE_W, h: SIDE_H };
    }

    // Canvas bounds
    const allPos = [...Object.values(nodePos), ...Object.values(sidePos)];
    const maxX = allPos.length > 0 ? Math.max(...allPos.map(p => p.x + p.w)) : SPINE_X + NODE_W;
    const maxY = allPos.length > 0 ? Math.max(...allPos.map(p => p.y + p.h)) : curY;
    const totalW = maxX + 160;
    const totalH = maxY + 60;

    // SVG edges
    let svgEdges = `<defs>
        <marker id="ov-arrow-flow" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
            <polygon points="0 0, 8 3, 0 6" fill="#3498db"/>
        </marker>
        <marker id="ov-arrow-branch" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
            <polygon points="0 0, 8 3, 0 6" fill="#e74c3c"/>
        </marker>
        <marker id="ov-arrow-loop" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
            <polygon points="0 0, 8 3, 0 6" fill="#f0883e"/>
        </marker>
        <marker id="ov-arrow-side" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
            <polygon points="0 0, 8 3, 0 6" fill="#8b949e"/>
        </marker>
        <marker id="ov-arrow-side-rev" markerWidth="8" markerHeight="6" refX="0" refY="3" orient="auto" markerUnits="strokeWidth">
            <polygon points="8 0, 0 3, 8 6" fill="#8b949e"/>
        </marker>
    </defs>`;

    function addLabel(x, y, text, color) {
        if (!text) return '';
        const tw = text.length * 5.5 + 8;
        return `<rect x="${x - tw/2}" y="${y - 11}" width="${tw}" height="15" class="ov-edge-label-bg"/>` +
               `<text x="${x - tw/2 + 4}" y="${y}" class="ov-edge-label"${color ? ` fill="${color}"` : ''}>${escapeHtml(text)}</text>`;
    }

    // Flow edges
    for (const fromId of Object.keys(flowTo)) {
        const fp = nodePos[fromId];
        if (!fp) continue;
        for (const ft of flowTo[fromId]) {
            const tp = nodePos[ft.target];
            if (!tp) continue;
            const x1 = fp.x + fp.w / 2, y1 = fp.y + fp.h;
            const x2 = tp.x + tp.w / 2, y2 = tp.y;
            if (Math.abs(x1 - x2) < 5) {
                svgEdges += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" class="ov-edge-flow" marker-end="url(#ov-arrow-flow)"/>`;
            } else {
                const my = (y1 + y2) / 2;
                svgEdges += `<path d="M${x1},${y1} C${x1},${my} ${x2},${my} ${x2},${y2}" class="ov-edge-flow" marker-end="url(#ov-arrow-flow)"/>`;
            }
            svgEdges += addLabel((x1 + x2) / 2 + (x1 === x2 ? 8 : 0), (y1 + y2) / 2, ft.label, null);
        }
    }

    // Branch edges
    for (const fromId of Object.keys(branchTo)) {
        const fp = nodePos[fromId];
        if (!fp) continue;
        for (let bi = 0; bi < branchTo[fromId].length; bi++) {
            const b = branchTo[fromId][bi];
            const tp = nodePos[b.target];
            if (!tp) continue;
            const fCx = fp.x + fp.w / 2, fBot = fp.y + fp.h;
            const tCx = tp.x + tp.w / 2, tTop = tp.y;
            const labelText = b.label || b.condition || '';

            if (tp.y > fp.y) {
                const ox = (bi === 0 ? -60 : 60) * Math.max(bi, 1);
                const my = (fBot + tTop) / 2;
                svgEdges += `<path d="M${fCx},${fBot} C${fCx + ox},${my} ${tCx + ox},${my} ${tCx},${tTop}" class="ov-edge-branch" marker-end="url(#ov-arrow-branch)"/>`;
                svgEdges += addLabel((fCx + tCx) / 2 + (bi === 0 ? -50 : 50), (fBot + tTop) / 2, labelText, '#e74c3c');
            } else {
                const ox = maxX + 40 + bi * 30;
                svgEdges += `<path d="M${fCx + fp.w/2},${fp.y + fp.h/2} C${ox},${fp.y + fp.h/2} ${ox},${tp.y + tp.h/2} ${tCx + tp.w/2},${tp.y + tp.h/2}" class="ov-edge-branch" marker-end="url(#ov-arrow-branch)"/>`;
                svgEdges += addLabel(ox + 5, (fp.y + tp.y) / 2 + fp.h / 2, labelText, '#e74c3c');
            }
        }
    }

    // Loop edges (right side arc)
    for (const fromId of Object.keys(loopsTo)) {
        const loop = loopsTo[fromId];
        const fp = nodePos[fromId];
        const tp = nodePos[loop.target];
        if (!fp || !tp) continue;
        const fR = fp.x + fp.w, fMy = fp.y + fp.h / 2;
        const tR = tp.x + tp.w, tMy = tp.y + tp.h / 2;
        const ox = maxX - SPINE_X + 50;
        svgEdges += `<path d="M${fR},${fMy} C${fR + ox},${fMy} ${tR + ox},${tMy} ${tR},${tMy}" class="ov-edge-loop" marker-end="url(#ov-arrow-loop)"/>`;
        svgEdges += addLabel(Math.max(fR, tR) + ox - 5, (fMy + tMy) / 2, loop.label || loop.condition || 'loop', '#f0883e');
    }

    // Side entity edges: one connection per (proc, entity) pair
    // Group usages by procId, then draw one line with appropriate arrowheads
    // Click the line to see full edge details in sidebar
    const sideEdgePairs = [];  // [{procId, entityId, usages, bidir}]
    for (const [eid, se] of Object.entries(sideEntities)) {
        // Group usages by procId
        const byProc = {};
        for (const u of se.usedBy) {
            if (!byProc[u.procId]) byProc[u.procId] = [];
            byProc[u.procId].push(u);
        }
        for (const [pid, usages] of Object.entries(byProc)) {
            const hasReturn = usages.some(u => u.edgeType === 'invoke' || u.edgeType === 'read');
            sideEdgePairs.push({ procId: pid, entityId: eid, usages, bidir: hasReturn });
        }
    }

    for (const pair of sideEdgePairs) {
        const fp = nodePos[pair.procId];
        const ep = sidePos[pair.entityId];
        if (!fp || !ep) continue;
        const x1 = fp.x + fp.w, x2 = ep.x;
        const yProc = fp.y + fp.h / 2;
        const yEnt = Math.max(ep.y + 4, Math.min(ep.y + ep.h - 4, yProc));
        const pairKey = `${pair.procId}__${pair.entityId}`;
        const markers = pair.bidir
            ? 'marker-start="url(#ov-arrow-side-rev)" marker-end="url(#ov-arrow-side)"'
            : 'marker-end="url(#ov-arrow-side)"';
        // Single visible line
        svgEdges += `<line x1="${x1}" y1="${yProc}" x2="${x2}" y2="${yEnt}" class="ov-edge-invoke" ${markers}/>`;
        // Fat invisible hit target for clicking
        svgEdges += `<line x1="${x1}" y1="${yProc}" x2="${x2}" y2="${yEnt}" stroke="transparent" stroke-width="14" data-ov-pair="${pairKey}" style="cursor:pointer;pointer-events:stroke"/>`;
    }

    // Store pairs for click handler
    ovSideEdgePairs = sideEdgePairs;

    // Store in module-level for drag interaction
    ovState = { nodePos, sidePos, displayNodes, sideEntities, flowTo, branchTo, loopsTo, entryId, collapsed };

    // Build HTML
    let html = '';

    html += `<div class="ov-legend">
        <div class="ov-legend-item"><div class="ov-legend-swatch" style="background:#2d333b;border:2px solid #484f58;"></div>Step</div>
        <div class="ov-legend-item"><div class="ov-legend-swatch" style="background:#2d333b;border:2px solid #f1c40f;clip-path:polygon(50% 0%,100% 50%,50% 100%,0% 50%);"></div>Gate</div>
        <div class="ov-legend-item"><div class="ov-legend-swatch" style="background:rgba(78,205,196,0.12);border:2px solid #4ecdc4;"></div>Agent</div>
        <div class="ov-legend-item"><div class="ov-legend-swatch" style="background:rgba(243,156,18,0.12);border:2px solid #f39c12;"></div>Tool</div>
        <div class="ov-legend-item"><div class="ov-legend-swatch" style="background:rgba(149,165,166,0.12);border:2px solid #95a5a6;"></div>Store</div>
        <div class="ov-legend-item"><div class="ov-legend-line" style="background:#3498db;"></div>Flow</div>
        <div class="ov-legend-item"><div class="ov-legend-line" style="background:repeating-linear-gradient(90deg,#e74c3c 0,#e74c3c 4px,transparent 4px,transparent 7px);"></div>Branch</div>
        <div class="ov-legend-item"><div class="ov-legend-line" style="background:repeating-linear-gradient(90deg,#f0883e 0,#f0883e 4px,transparent 4px,transparent 7px);"></div>Loop</div>
    </div>`;

    const collapsedCount = Object.keys(collapsed).length;
    html += `<div class="ov-title-bar"><strong>${spec.name || 'Agent'}</strong> -- Overview &middot; ${displayNodes.length} nodes${collapsedCount > 0 ? ` (${collapsedCount} collapsed)` : ''} &middot; ${Object.keys(sideEntities).length} entities</div>`;

    html += `<div class="ov-canvas" id="ov-canvas" style="width:${totalW}px;height:${totalH}px;">`;
    html += `<svg class="ov-svg-layer" id="ov-svg" width="${totalW}" height="${totalH}">${svgEdges}</svg>`;

    // Display nodes (draggable)
    for (const dn of displayNodes) {
        const pos = nodePos[dn.id];
        if (!pos) continue;
        const isEntry = dn.procId === entryId;

        if (dn.type === 'gate') {
            html += `<div class="ov-drag" data-ov-id="${dn.id}" data-ov-kind="node" style="position:absolute;left:${pos.x}px;top:${pos.y}px;width:${pos.w}px;height:${pos.h}px;z-index:5;cursor:grab;">`;
            html += `<div style="position:absolute;inset:0;background:#2d333b;border:2px solid #f1c40f;clip-path:polygon(50% 0%,100% 50%,50% 100%,0% 50%);"></div>`;
            html += `<div style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:0.75em;font-weight:600;color:#f1c40f;z-index:6;">${escapeHtml(dn.label)}</div>`;
            html += `</div>`;
        } else if (dn.type === 'agent') {
            let cls = 'ov-node ov-node-agent';
            if (isEntry) cls += ' ov-node-entry';
            html += `<div class="${cls} ov-drag" data-ov-id="${dn.id}" data-ov-kind="node" style="left:${pos.x}px;top:${pos.y}px;width:${pos.w}px;height:${pos.h}px;cursor:grab;">${escapeHtml(dn.label)}</div>`;
        } else {
            let cls = 'ov-node ov-node-step';
            if (isEntry) cls += ' ov-node-entry';
            if (dn.type === 'checkpoint') cls = 'ov-node ov-node-human' + (isEntry ? ' ov-node-entry' : '');
            html += `<div class="${cls} ov-drag" data-ov-id="${dn.id}" data-ov-kind="node" style="left:${pos.x}px;top:${pos.y}px;width:${pos.w}px;height:${pos.h}px;cursor:grab;">${escapeHtml(dn.label)}</div>`;
        }
    }

    // Side entity nodes (draggable)
    for (const [eid, se] of Object.entries(sideEntities)) {
        const pos = sidePos[eid];
        if (!pos) continue;
        const cls = se.type === 'tool' ? 'ov-node-tool'
            : se.type === 'store' ? 'ov-node-store'
            : se.type === 'human' ? 'ov-node-human'
            : 'ov-node-agent';
        html += `<div class="ov-node ${cls} ov-drag" data-ov-id="${eid}" data-ov-kind="side" style="left:${pos.x}px;top:${pos.y}px;width:${pos.w}px;height:${pos.h}px;cursor:grab;">${escapeHtml(se.label)}</div>`;
    }

    html += '</div>';
    container.innerHTML = html;
    ovInitDrag();
    ovInitEdgeClick();
}

// Module-level overview state for drag
let ovState = null;
let ovSideEdgePairs = [];
let ovDragTarget = null;
let ovDragStartX = 0, ovDragStartY = 0;

function ovInitDrag() {
    const canvas = document.getElementById('ov-canvas');
    if (!canvas) return;

    canvas.addEventListener('mousedown', (ev) => {
        const el = ev.target.closest('.ov-drag');
        if (!el) return;
        ev.preventDefault();
        ovDragTarget = el;
        ovDragStartX = ev.clientX;
        ovDragStartY = ev.clientY;
        el.style.cursor = 'grabbing';
        el.style.zIndex = '20';
    });

    canvas.addEventListener('mousemove', (ev) => {
        if (!ovDragTarget || !ovState) return;
        const dx = ev.clientX - ovDragStartX;
        const dy = ev.clientY - ovDragStartY;
        ovDragStartX = ev.clientX;
        ovDragStartY = ev.clientY;

        const id = ovDragTarget.dataset.ovId;
        const kind = ovDragTarget.dataset.ovKind;
        const posMap = kind === 'side' ? ovState.sidePos : ovState.nodePos;
        const pos = posMap[id];
        if (!pos) return;

        pos.x += dx;
        pos.y += dy;
        ovDragTarget.style.left = pos.x + 'px';
        ovDragTarget.style.top = pos.y + 'px';

        ovRedrawSVG();
    });

    canvas.addEventListener('mouseup', () => {
        if (ovDragTarget) {
            ovDragTarget.style.cursor = 'grab';
            ovDragTarget.style.zIndex = '';
            ovDragTarget = null;
        }
    });

    canvas.addEventListener('mouseleave', () => {
        if (ovDragTarget) {
            ovDragTarget.style.cursor = 'grab';
            ovDragTarget.style.zIndex = '';
            ovDragTarget = null;
        }
    });

    // Click to select (only if not dragged)
    canvas.addEventListener('click', (ev) => {
        const el = ev.target.closest('.ov-drag');
        if (!el) return;
        const id = el.dataset.ovId;
        const kind = el.dataset.ovKind;
        if (kind === 'side') {
            ovSelectEntity(id);
        } else {
            ovSelectProcess(id);
        }
    });
}

function ovRedrawSVG() {
    if (!ovState) return;
    const { nodePos, sidePos, displayNodes, sideEntities, flowTo, branchTo, loopsTo, entryId } = ovState;

    // Recompute maxX for loop arcs
    const allPos = [...Object.values(nodePos), ...Object.values(sidePos)];
    const maxX = allPos.length > 0 ? Math.max(...allPos.map(p => p.x + p.w)) : 400;
    const SPINE_X = 200;

    let svgEdges = `<defs>
        <marker id="ov-arrow-flow" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto" markerUnits="strokeWidth"><polygon points="0 0, 8 3, 0 6" fill="#3498db"/></marker>
        <marker id="ov-arrow-branch" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto" markerUnits="strokeWidth"><polygon points="0 0, 8 3, 0 6" fill="#e74c3c"/></marker>
        <marker id="ov-arrow-loop" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto" markerUnits="strokeWidth"><polygon points="0 0, 8 3, 0 6" fill="#f0883e"/></marker>
        <marker id="ov-arrow-side" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto" markerUnits="strokeWidth"><polygon points="0 0, 8 3, 0 6" fill="#8b949e"/></marker>
        <marker id="ov-arrow-side-rev" markerWidth="8" markerHeight="6" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><polygon points="8 0, 0 3, 8 6" fill="#8b949e"/></marker>
    </defs>`;

    function addLabel(x, y, text, color) {
        if (!text) return '';
        const tw = text.length * 5.5 + 8;
        return `<rect x="${x - tw/2}" y="${y - 11}" width="${tw}" height="15" class="ov-edge-label-bg"/>` +
               `<text x="${x - tw/2 + 4}" y="${y}" class="ov-edge-label"${color ? ` fill="${color}"` : ''}>${escapeHtml(text)}</text>`;
    }

    // Flow
    for (const fromId of Object.keys(flowTo)) {
        const fp = nodePos[fromId];
        if (!fp) continue;
        for (const ft of flowTo[fromId]) {
            const tp = nodePos[ft.target];
            if (!tp) continue;
            const x1 = fp.x + fp.w / 2, y1 = fp.y + fp.h;
            const x2 = tp.x + tp.w / 2, y2 = tp.y;
            if (Math.abs(x1 - x2) < 5) {
                svgEdges += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" class="ov-edge-flow" marker-end="url(#ov-arrow-flow)"/>`;
            } else {
                const my = (y1 + y2) / 2;
                svgEdges += `<path d="M${x1},${y1} C${x1},${my} ${x2},${my} ${x2},${y2}" class="ov-edge-flow" marker-end="url(#ov-arrow-flow)"/>`;
            }
            svgEdges += addLabel((x1 + x2) / 2 + (Math.abs(x1 - x2) < 5 ? 8 : 0), (y1 + y2) / 2, ft.label, null);
        }
    }

    // Branch
    for (const fromId of Object.keys(branchTo)) {
        const fp = nodePos[fromId];
        if (!fp) continue;
        for (let bi = 0; bi < branchTo[fromId].length; bi++) {
            const b = branchTo[fromId][bi];
            const tp = nodePos[b.target];
            if (!tp) continue;
            const fCx = fp.x + fp.w / 2, fBot = fp.y + fp.h;
            const tCx = tp.x + tp.w / 2, tTop = tp.y;
            const labelText = b.label || b.condition || '';
            if (tp.y > fp.y) {
                const ox = (bi === 0 ? -60 : 60) * Math.max(bi, 1);
                const my = (fBot + tTop) / 2;
                svgEdges += `<path d="M${fCx},${fBot} C${fCx + ox},${my} ${tCx + ox},${my} ${tCx},${tTop}" class="ov-edge-branch" marker-end="url(#ov-arrow-branch)"/>`;
                svgEdges += addLabel((fCx + tCx) / 2 + (bi === 0 ? -50 : 50), (fBot + tTop) / 2, labelText, '#e74c3c');
            } else {
                const ox = maxX + 40 + bi * 30;
                svgEdges += `<path d="M${fCx + fp.w/2},${fp.y + fp.h/2} C${ox},${fp.y + fp.h/2} ${ox},${tp.y + tp.h/2} ${tCx + tp.w/2},${tp.y + tp.h/2}" class="ov-edge-branch" marker-end="url(#ov-arrow-branch)"/>`;
                svgEdges += addLabel(ox + 5, (fp.y + tp.y) / 2 + fp.h / 2, labelText, '#e74c3c');
            }
        }
    }

    // Loop
    for (const fromId of Object.keys(loopsTo)) {
        const loop = loopsTo[fromId];
        const fp = nodePos[fromId];
        const tp = nodePos[loop.target];
        if (!fp || !tp) continue;
        const fR = fp.x + fp.w, fMy = fp.y + fp.h / 2;
        const tR = tp.x + tp.w, tMy = tp.y + tp.h / 2;
        const ox = maxX - Math.min(fp.x, tp.x) + 50;
        svgEdges += `<path d="M${fR},${fMy} C${fR + ox},${fMy} ${tR + ox},${tMy} ${tR},${tMy}" class="ov-edge-loop" marker-end="url(#ov-arrow-loop)"/>`;
        svgEdges += addLabel(Math.max(fR, tR) + ox - 5, (fMy + tMy) / 2, loop.label || loop.condition || 'loop', '#f0883e');
    }

    // Side entity edges: one connection per (proc, entity) pair
    for (const pair of ovSideEdgePairs) {
        const fp = nodePos[pair.procId];
        const ep = sidePos[pair.entityId];
        if (!fp || !ep) continue;
        const x1 = fp.x + fp.w, x2 = ep.x;
        const yProc = fp.y + fp.h / 2;
        const yEnt = Math.max(ep.y + 4, Math.min(ep.y + ep.h - 4, yProc));
        const pairKey = `${pair.procId}__${pair.entityId}`;
        const markers = pair.bidir
            ? 'marker-start="url(#ov-arrow-side-rev)" marker-end="url(#ov-arrow-side)"'
            : 'marker-end="url(#ov-arrow-side)"';
        svgEdges += `<line x1="${x1}" y1="${yProc}" x2="${x2}" y2="${yEnt}" class="ov-edge-invoke" ${markers}/>`;
        svgEdges += `<line x1="${x1}" y1="${yProc}" x2="${x2}" y2="${yEnt}" stroke="transparent" stroke-width="14" data-ov-pair="${pairKey}" style="cursor:pointer;pointer-events:stroke"/>`;
    }

    const svg = document.getElementById('ov-svg');
    if (svg) {
        // Resize SVG to fit
        const allP = [...Object.values(nodePos), ...Object.values(sidePos)];
        const newW = Math.max(...allP.map(p => p.x + p.w)) + 160;
        const newH = Math.max(...allP.map(p => p.y + p.h)) + 60;
        svg.setAttribute('width', newW);
        svg.setAttribute('height', newH);
        svg.innerHTML = svgEdges;
        // Also resize canvas
        const canvas = document.getElementById('ov-canvas');
        if (canvas) {
            canvas.style.width = newW + 'px';
            canvas.style.height = newH + 'px';
        }
    }
}

function ovSelectProcess(procId) {
    const n = nodes.find(n => n.id === procId);
    if (n) {
        selectedNode = n;
        const sidebar = document.getElementById('sidebar');
        sidebar.style.display = '';
        renderSidebar();
    }
}

function ovSelectEntity(entityId) {
    const n = nodes.find(n => n.id === entityId);
    if (n) {
        selectedNode = n;
        const sidebar = document.getElementById('sidebar');
        sidebar.style.display = '';
        renderSidebar();
    }
}

function ovInitEdgeClick() {
    const svg = document.getElementById('ov-svg');
    if (!svg) return;
    svg.addEventListener('click', (e) => {
        const pairKey = e.target.getAttribute('data-ov-pair');
        if (!pairKey) return;
        const pair = ovSideEdgePairs.find(p => `${p.procId}__${p.entityId}` === pairKey);
        if (!pair) return;
        ovShowEdgeDetail(pair);
    });
}

function ovShowEdgeDetail(pair) {
    const sidebar = document.getElementById('sidebar');
    sidebar.style.display = '';
    const proc = (spec.processes || []).find(p => p.id === pair.procId);
    const ent = (spec.entities || []).find(e => e.id === pair.entityId);
    const procLabel = proc ? (proc.label || proc.id) : pair.procId;
    const entLabel = ent ? (ent.label || ent.id) : pair.entityId;

    let html = `<h3 style="margin:0 0 8px;font-size:1em;color:#e6edf3;">Connection</h3>`;
    html += `<div style="margin-bottom:12px;color:#8b949e;font-size:0.85em;">
        <strong style="color:#c9d1d9;">${escapeHtml(procLabel)}</strong> &harr;
        <strong style="color:#c9d1d9;">${escapeHtml(entLabel)}</strong>
    </div>`;

    for (const u of pair.usages) {
        const arrow = u.edgeType === 'write' ? '&rarr;' : '&harr;';
        const typeColor = u.edgeType === 'invoke' ? '#4ecdc4'
            : u.edgeType === 'read' ? '#2ecc71'
            : '#f39c12';
        html += `<div style="margin-bottom:10px;padding:8px;background:#161b22;border-radius:6px;border-left:3px solid ${typeColor};">`;
        html += `<div style="font-weight:600;color:${typeColor};font-size:0.8em;text-transform:uppercase;margin-bottom:4px;">${u.edgeType}</div>`;
        if (u.edgeLabel) {
            html += `<div style="color:#c9d1d9;font-size:0.85em;margin-bottom:2px;">${escapeHtml(u.edgeLabel)}</div>`;
        }
        if (u.returnLabel) {
            html += `<div style="color:#8b949e;font-size:0.8em;">Returns: <span style="color:#c9d1d9;">${escapeHtml(u.returnLabel)}</span></div>`;
        }
        html += `</div>`;
    }

    sidebar.innerHTML = html;
}

// =====================================================================
// ENHANCED State Machine View
// =====================================================================

function renderStateMachine() {
    if (!spec) return;
    const container = document.getElementById('sm-view');
    const processes = spec.processes || [];
    const specEdges = spec.edges || [];
    const entities = spec.entities || [];

    // Build adjacency maps
    const flowTo = {};     // processId -> [{target, label}]
    const branchTo = {};   // processId -> [{target, label, condition}]
    const invokedBy = {};  // processId -> [{entityId, entityLabel, entityType, input, output}]
    const loopsTo = {};    // processId -> {target, label, condition}

    for (const e of specEdges) {
        if (e.type === 'flow') {
            const fromProc = processes.find(p => p.id === e.from);
            const toProc = processes.find(p => p.id === e.to);
            if (fromProc && toProc) {
                if (!flowTo[e.from]) flowTo[e.from] = [];
                flowTo[e.from].push({ target: e.to, label: e.label || '' });
            }
        }
        if (e.type === 'branch') {
            const fromProc = processes.find(p => p.id === e.from);
            const toProc = processes.find(p => p.id === e.to);
            if (fromProc && toProc) {
                if (!branchTo[e.from]) branchTo[e.from] = [];
                branchTo[e.from].push({ target: e.to, label: e.label || '', condition: e.condition || '' });
            }
        }
        if (e.type === 'invoke') {
            const fromProc = processes.find(p => p.id === e.from);
            const toEntity = entities.find(en => en.id === e.to);
            if (fromProc && toEntity) {
                if (!invokedBy[e.from]) invokedBy[e.from] = [];
                invokedBy[e.from].push({
                    entityId: e.to,
                    entityLabel: toEntity.label || e.to,
                    entityType: toEntity.type,
                    input: e.input,
                    output: e.output
                });
            }
        }
        if (e.type === 'loop') {
            const fromProc = processes.find(p => p.id === e.from);
            const toProc = processes.find(p => p.id === e.to);
            if (fromProc && toProc) {
                loopsTo[e.from] = { target: e.to, label: e.label || '', condition: e.condition || '' };
            }
        }
    }

    // Walk the flow spine via BFS from entry point
    const entryId = spec.entry_point || (processes[0] && processes[0].id);
    const spine = [];
    const visited = new Set();

    function walkFlow(startId) {
        const queue = [startId];
        while (queue.length > 0) {
            const id = queue.shift();
            if (visited.has(id)) continue;
            const proc = processes.find(p => p.id === id);
            if (!proc) continue;
            visited.add(id);
            spine.push(proc);

            // Follow flow edges then branch targets
            const flows = (flowTo[id] || []).map(f => f.target);
            const branches = (branchTo[id] || []).map(b => b.target);
            // Also follow gate branches defined in the process itself
            const procBranches = (proc.branches || []).map(b => b.target);
            const allTargets = [...flows, ...branches, ...procBranches];
            for (const t of allTargets) {
                if (!visited.has(t)) queue.push(t);
            }
        }
    }
    walkFlow(entryId);

    // Add orphan processes
    for (const p of processes) {
        if (!visited.has(p.id)) {
            spine.push(p);
            visited.add(p.id);
        }
    }

    // Compute layout positions for each process node
    const NODE_W = 180;
    const NODE_H_STEP = 56;
    const NODE_H_GATE = 80;
    const NODE_H_CP = 60;
    const GAP_Y = 80;
    const CANVAS_PAD_LEFT = 200;
    const CANVAS_PAD_TOP = 20;

    // Assign column and row for each process
    // Simple: single-column layout centered, with branches shown as labeled edges
    const positions = {};
    let curY = CANVAS_PAD_TOP;
    const centerX = 400;

    for (let i = 0; i < spine.length; i++) {
        const proc = spine[i];
        const h = proc.type === 'gate' ? NODE_H_GATE : (proc.type === 'checkpoint' ? NODE_H_CP : NODE_H_STEP);
        positions[proc.id] = { x: centerX, y: curY, w: NODE_W, h: h };
        curY += h + GAP_Y;
    }

    const totalH = curY + 60;
    const totalW = centerX * 2 + NODE_W + 300;

    // Build SVG edges
    let svgEdges = '';
    const ARROW_ID = 'sm-arrowhead';
    const ARROW_LOOP_ID = 'sm-arrowhead-loop';
    const ARROW_BRANCH_ID = 'sm-arrowhead-branch';

    svgEdges += `<defs>
        <marker id="${ARROW_ID}" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
            <polygon points="0 0, 8 3, 0 6" fill="#3498db"/>
        </marker>
        <marker id="${ARROW_LOOP_ID}" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
            <polygon points="0 0, 8 3, 0 6" fill="#f0883e"/>
        </marker>
        <marker id="${ARROW_BRANCH_ID}" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
            <polygon points="0 0, 8 3, 0 6" fill="#e74c3c"/>
        </marker>
    </defs>`;

    // Flow edges: straight down
    for (const fromId of Object.keys(flowTo)) {
        const fromPos = positions[fromId];
        if (!fromPos) continue;
        for (const ft of flowTo[fromId]) {
            const toPos = positions[ft.target];
            if (!toPos) continue;
            const x1 = fromPos.x + fromPos.w / 2;
            const y1 = fromPos.y + fromPos.h;
            const x2 = toPos.x + toPos.w / 2;
            const y2 = toPos.y;

            if (Math.abs(x1 - x2) < 5) {
                // Straight vertical
                svgEdges += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" class="sm-edge-flow" marker-end="url(#${ARROW_ID})"/>`;
            } else {
                // Curved path
                const midY = (y1 + y2) / 2;
                svgEdges += `<path d="M${x1},${y1} C${x1},${midY} ${x2},${midY} ${x2},${y2}" class="sm-edge-flow" marker-end="url(#${ARROW_ID})"/>`;
            }

            // Label
            if (ft.label) {
                const lx = (x1 + x2) / 2 + 8;
                const ly = (y1 + y2) / 2;
                svgEdges += `<rect x="${lx - 2}" y="${ly - 10}" width="${ft.label.length * 6 + 6}" height="14" class="sm-edge-label-bg"/>`;
                svgEdges += `<text x="${lx + 2}" y="${ly}" class="sm-edge-label">${escapeHtml(ft.label)}</text>`;
            }
        }
    }

    // Branch edges: from gates
    for (const fromId of Object.keys(branchTo)) {
        const fromPos = positions[fromId];
        if (!fromPos) continue;
        const branches = branchTo[fromId];
        for (let bi = 0; bi < branches.length; bi++) {
            const b = branches[bi];
            const toPos = positions[b.target];
            if (!toPos) continue;

            const fromCx = fromPos.x + fromPos.w / 2;
            const fromBot = fromPos.y + fromPos.h;
            const toCx = toPos.x + toPos.w / 2;
            const toTop = toPos.y;

            // If target is below the source, use a slight offset
            if (toPos.y > fromPos.y) {
                // Side offset based on branch index
                const offsetX = (bi === 0 ? -60 : 60) * (bi > 1 ? bi : 1);
                const midY = (fromBot + toTop) / 2;
                svgEdges += `<path d="M${fromCx},${fromBot} C${fromCx + offsetX},${midY} ${toCx + offsetX},${midY} ${toCx},${toTop}" class="sm-edge-branch" marker-end="url(#${ARROW_BRANCH_ID})"/>`;
            } else {
                // Target is above (loop-like branch)
                const offsetX = 220 + bi * 30;
                svgEdges += `<path d="M${fromCx + fromPos.w/2},${fromPos.y + fromPos.h/2} C${fromCx + offsetX},${fromPos.y + fromPos.h/2} ${toCx + offsetX},${toPos.y + toPos.h/2} ${toCx + toPos.w/2},${toPos.y + toPos.h/2}" class="sm-edge-branch" marker-end="url(#${ARROW_BRANCH_ID})"/>`;
            }

            // Branch label
            const lx = (fromCx + toCx) / 2 + (bi === 0 ? -70 : 50);
            const ly = (fromBot + toTop) / 2;
            const labelText = b.label || b.condition || '';
            if (labelText) {
                svgEdges += `<rect x="${lx - 2}" y="${ly - 10}" width="${labelText.length * 5.5 + 8}" height="14" class="sm-edge-label-bg"/>`;
                svgEdges += `<text x="${lx + 2}" y="${ly}" class="sm-edge-label" fill="#e74c3c">${escapeHtml(labelText)}</text>`;
            }
        }
    }

    // Loop edges: dashed arcs going back up
    for (const fromId of Object.keys(loopsTo)) {
        const loop = loopsTo[fromId];
        const fromPos = positions[fromId];
        const toPos = positions[loop.target];
        if (!fromPos || !toPos) continue;

        const fromRight = fromPos.x + fromPos.w;
        const fromMidY = fromPos.y + fromPos.h / 2;
        const toRight = toPos.x + toPos.w;
        const toMidY = toPos.y + toPos.h / 2;
        const offsetX = 80;

        svgEdges += `<path d="M${fromRight},${fromMidY} C${fromRight + offsetX},${fromMidY} ${toRight + offsetX},${toMidY} ${toRight},${toMidY}" class="sm-edge-loop" marker-end="url(#${ARROW_LOOP_ID})"/>`;

        // Label
        const lx = Math.max(fromRight, toRight) + offsetX + 5;
        const ly = (fromMidY + toMidY) / 2;
        const loopLabel = loop.label || loop.condition || 'loop';
        svgEdges += `<rect x="${lx - 2}" y="${ly - 10}" width="${loopLabel.length * 5.5 + 8}" height="14" class="sm-edge-label-bg"/>`;
        svgEdges += `<text x="${lx + 2}" y="${ly}" class="sm-edge-label" fill="#f0883e">${escapeHtml(loopLabel)}</text>`;
    }

    // Build HTML
    let html = '';

    // Legend bar
    html += `<div class="sm-legend">
        <div class="sm-legend-item"><div class="sm-legend-shape" style="background:rgba(52,152,219,0.15);border:2px solid #3498db;border-radius:6px;"></div>Step</div>
        <div class="sm-legend-item"><div class="sm-legend-shape" style="background:rgba(241,196,15,0.15);border:2px solid #f1c40f;clip-path:polygon(50% 0%,100% 50%,50% 100%,0% 50%);"></div>Gate</div>
        <div class="sm-legend-item"><div class="sm-legend-shape" style="background:rgba(230,126,34,0.15);border:2px solid #e67e22;clip-path:polygon(30% 0%,70% 0%,100% 30%,100% 70%,70% 100%,30% 100%,0% 70%,0% 30%);"></div>Checkpoint</div>
        <div class="sm-legend-item"><div class="sm-legend-shape" style="background:rgba(155,89,182,0.12);border:3px double #9b59b6;border-radius:3px;"></div>Spawn</div>
        <div class="sm-legend-item"><div class="sm-legend-line" style="background:#3498db;"></div>Flow</div>
        <div class="sm-legend-item"><div class="sm-legend-line" style="background:repeating-linear-gradient(90deg,#f0883e 0,#f0883e 4px,transparent 4px,transparent 7px);"></div>Loop</div>
        <div class="sm-legend-item"><div class="sm-legend-line" style="background:repeating-linear-gradient(90deg,#e74c3c 0,#e74c3c 4px,transparent 4px,transparent 7px);"></div>Branch</div>
        <div class="sm-legend-item" style="border:2px solid #7ee787;border-radius:4px;padding:0 4px;">Entry</div>
    </div>`;

    html += `<div class="sm-title-bar"><strong>${spec.name || 'Agent'}</strong> -- State Machine Flow &middot; ${processes.length} processes</div>`;

    // Canvas container
    html += `<div class="sm-canvas" style="width:${totalW}px;height:${totalH}px;">`;

    // SVG layer for edges
    html += `<svg class="sm-svg-layer" width="${totalW}" height="${totalH}">${svgEdges}</svg>`;

    // Process nodes
    for (const proc of spine) {
        const pos = positions[proc.id];
        if (!pos) continue;

        const isEntry = proc.id === entryId;
        const typeClass = `sm-proc-${proc.type}`;
        const entryClass = isEntry ? 'sm-proc-entry' : '';

        // Get trace data if available
        let traceHtml = '';
        if (traceData && traceData.processes) {
            const td = traceData.processes[proc.id];
            if (td) {
                if (td.count !== undefined) {
                    traceHtml += `<div class="trace-badge" title="Execution count: ${td.count}">${td.count}</div>`;
                }
                if (td.duration_ms !== undefined) {
                    const dur = td.duration_ms;
                    const maxDur = traceData._maxDuration || 1000;
                    const ratio = Math.min(dur / maxDur, 1);
                    // Red=slow, green=fast
                    const r = Math.round(200 * ratio + 55);
                    const g = Math.round(200 * (1 - ratio) + 55);
                    const bgColor = `rgb(${r},${g},60)`;
                    traceHtml += `<div class="trace-duration" style="background:${bgColor}" title="Duration: ${dur}ms">${dur}ms</div>`;
                }
                if (td.llm_calls !== undefined && td.llm_calls > 0) {
                    traceHtml += `<div class="trace-llm-badge" title="LLM calls: ${td.llm_calls}">LLM:${td.llm_calls}</div>`;
                }
            }
        }

        html += `<div class="sm-proc ${typeClass} ${entryClass}" data-proc-id="${proc.id}"
                      style="left:${pos.x}px;top:${pos.y}px;width:${pos.w}px;height:${pos.h}px;"
                      onclick="smSelectProcess('${proc.id}')">`;
        html += traceHtml;
        html += `<div class="sm-proc-name">${proc.label || proc.id}</div>`;
        html += `<div class="sm-proc-type">${proc.type}${proc.id !== (proc.label || '').toLowerCase().replace(/\s+/g, '_') ? ' : ' + proc.id : ''}</div>`;

        // Data flow tags (left side) — from process or invoke edges
        let dataIn = proc.data_in || proc.input_schema || '';
        let dataOut = proc.data_out || proc.output_schema || '';
        // Fall back to invoke edge schemas if process doesn't define them
        if (!dataIn || !dataOut) {
            const invEdges = invokedBy[proc.id] || [];
            if (invEdges.length > 0) {
                if (!dataIn && invEdges[0].input) dataIn = invEdges[0].input;
                if (!dataOut && invEdges[0].output) dataOut = invEdges[0].output;
            }
        }
        if (dataIn || dataOut) {
            html += `<div class="sm-data-flow">`;
            if (dataIn) {
                html += `<div class="sm-data-tag sm-data-tag-in" title="Input: ${dataIn}" onclick="scrollToSchema('${dataIn}')">${dataIn}</div>`;
            }
            if (dataOut) {
                html += `<div class="sm-data-tag sm-data-tag-out" title="Output: ${dataOut}" onclick="scrollToSchema('${dataOut}')">${dataOut}</div>`;
            }
            html += `</div>`;
        }

        // Invoke badges on the side
        const invokes = invokedBy[proc.id] || [];
        if (invokes.length > 0) {
            html += `<div class="sm-invoke-sidebar">`;
            // Show at most 5 individually, then a count
            const shown = invokes.slice(0, 5);
            const remaining = invokes.length - shown.length;
            for (const inv of shown) {
                const chipClass = inv.entityType === 'agent' ? 'sm-invoke-chip-agent' : 'sm-invoke-chip-tool';
                const icon = inv.entityType === 'agent' ? '<svg class="inv-icon" viewBox="0 0 10 10"><circle cx="5" cy="3" r="2" fill="currentColor"/><path d="M1,9 Q5,6 9,9" stroke="currentColor" fill="none" stroke-width="1"/></svg>'
                    : '<svg class="inv-icon" viewBox="0 0 10 10"><rect x="1" y="3" width="8" height="5" rx="1" fill="none" stroke="currentColor" stroke-width="1"/><line x1="5" y1="1" x2="5" y2="3" stroke="currentColor" stroke-width="1"/></svg>';
                html += `<div class="sm-invoke-chip ${chipClass}" title="${inv.entityLabel}${inv.input ? ' ('+inv.input+')' : ''}">${icon}${inv.entityLabel}</div>`;
            }
            if (remaining > 0) {
                html += `<div class="sm-invoke-chip" title="${remaining} more invocations">+${remaining} more</div>`;
            }
            html += `</div>`;
        }

        html += `</div>`;
    }

    html += '</div>'; // End sm-canvas

    container.innerHTML = html;
}

function smSelectProcess(procId) {
    const n = nodes.find(n => n.id === procId);
    if (n) {
        selectedNode = n;
        renderSidebar();
        // Highlight the clicked node
        document.querySelectorAll('.sm-proc.sm-selected').forEach(el => el.classList.remove('sm-selected'));
        const el = document.querySelector(`.sm-proc[data-proc-id="${procId}"]`);
        if (el) el.classList.add('sm-selected');
    }
}

// =====================================================================
// ENHANCED Schemas View
// =====================================================================

function renderSchemas() {
    if (!spec) return;
    const container = document.getElementById('schemas-view');
    const schemas = spec.schemas || [];

    // Build usage map
    const usedBy = {};
    for (const s of schemas) usedBy[s.name] = [];

    function trackRef(name, label, refType) {
        if (usedBy[name]) usedBy[name].push({ label, refType });
    }

    for (const e of (spec.entities || [])) {
        if (e.input_schema) trackRef(e.input_schema, e.label || e.id, 'entity');
        if (e.output_schema) trackRef(e.output_schema, e.label || e.id, 'entity');
        if (e.schema) trackRef(e.schema, e.label || e.id, 'entity');
    }
    for (const p of (spec.processes || [])) {
        if (p.data_in) trackRef(p.data_in, p.label || p.id, 'process');
        if (p.data_out) trackRef(p.data_out, p.label || p.id, 'process');
        if (p.input_schema) trackRef(p.input_schema, p.label || p.id, 'process');
        if (p.output_schema) trackRef(p.output_schema, p.label || p.id, 'process');
    }
    for (const e of (spec.edges || [])) {
        if (e.data) trackRef(e.data, `${e.from} \u2192 ${e.to}`, 'edge');
        if (e.input) trackRef(e.input, `${e.from} \u2192 ${e.to}`, 'edge');
        if (e.output) trackRef(e.output, `${e.from} \u2192 ${e.to}`, 'edge');
    }

    // Build a set of known schema names for cross-referencing
    const schemaNames = new Set(schemas.map(s => s.name));

    // Classify a field type and extract references
    function classifyType(typeStr) {
        if (!typeStr) return { cls: 'sft-object', refs: [] };
        const str = String(typeStr);
        const refs = [];

        // Extract type references: look for schema names inside the type string
        for (const sn of schemaNames) {
            if (str.includes(sn)) {
                refs.push(sn);
            }
        }

        const lower = str.toLowerCase();
        if (lower === 'string' || lower.startsWith('string')) return { cls: 'sft-string', refs };
        if (lower === 'integer' || lower === 'number' || lower === 'int' || lower === 'float') return { cls: 'sft-integer', refs };
        if (lower === 'boolean' || lower === 'bool') return { cls: 'sft-integer', refs };
        if (lower.startsWith('list') || lower.startsWith('array')) return { cls: 'sft-list', refs };
        if (lower.startsWith('enum')) return { cls: 'sft-enum', refs };
        if (lower === 'datetime' || lower === 'date') return { cls: 'sft-datetime', refs };
        if (lower === 'object') return { cls: 'sft-object', refs };

        // If it contains a reference to another schema, mark as ref
        if (refs.length > 0) return { cls: 'sft-ref', refs };

        return { cls: 'sft-object', refs };
    }

    // Render type with clickable references
    function renderType(typeStr) {
        if (!typeStr) return '<span class="schema-field-type sft-object">object</span>';
        const str = String(typeStr);
        const { cls, refs } = classifyType(str);

        if (refs.length > 0) {
            // Replace schema name references with clickable links
            let rendered = escapeHtml(str);
            for (const ref of refs) {
                rendered = rendered.replace(ref, `<span class="sft-ref" onclick="scrollToSchema('${ref}')" title="Jump to ${ref}">${ref}</span>`);
            }
            return `<span class="schema-field-type ${cls}">${rendered}</span>`;
        }

        return `<span class="schema-field-type ${cls}">${escapeHtml(str)}</span>`;
    }

    let html = '';
    html += `<div class="schemas-summary">${schemas.length} schemas defined in <strong>${spec.name || 'spec'}</strong></div>`;
    html += `<div class="schemas-filter"><input type="text" id="schema-filter-input" placeholder="Filter schemas by name or field..." oninput="filterSchemas(this.value)"></div>`;
    html += '<div class="schemas-grid" id="schemas-grid">';

    for (const schema of schemas) {
        const fieldCount = (schema.fields || []).length;
        const refs = usedBy[schema.name] || [];

        html += `<div class="schema-card" id="schema-card-${schema.name}" data-schema-name="${(schema.name || '').toLowerCase()}" data-fields="${(schema.fields || []).map(f => f.name + ' ' + f.type).join(' ').toLowerCase()}">`;
        html += `<div class="schema-card-name">${schema.name} <span class="schema-count">${fieldCount} field${fieldCount !== 1 ? 's' : ''}</span></div>`;
        if (schema.description) {
            html += `<div class="schema-card-desc">${schema.description}</div>`;
        }

        for (const f of (schema.fields || [])) {
            html += `<div class="schema-field-row">`;
            html += `<span class="schema-field-name">${f.name}${f.optional ? '<span class="schema-field-optional">?</span>' : ''}</span>`;
            html += `<span>`;
            html += renderType(f.type);
            if (f.default !== undefined) {
                html += ` <span class="schema-field-default">= ${f.default}</span>`;
            }
            html += `</span>`;
            html += `</div>`;
        }

        // Cross-references: who uses this schema
        if (refs.length > 0) {
            html += `<div class="schema-refs">`;
            html += `<div class="schema-refs-title">Referenced by</div>`;
            for (const r of refs) {
                const tagClass = r.refType === 'process' ? 'schema-ref-tag-process'
                    : r.refType === 'entity' ? 'schema-ref-tag-entity'
                    : 'schema-ref-tag-edge';
                html += `<span class="schema-ref-tag ${tagClass}" title="${r.refType}: ${r.label}">${r.label}</span>`;
            }
            html += `</div>`;
        }

        html += `</div>`;
    }

    html += '</div>';
    container.innerHTML = html;
}

function scrollToSchema(name) {
    const card = document.getElementById('schema-card-' + name);
    if (card) {
        // If we're not on schemas view, switch to it
        if (currentView !== 'schemas') {
            switchView('schemas');
        }
        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
        card.classList.add('schema-highlight');
        setTimeout(() => card.classList.remove('schema-highlight'), 2000);
    }
}

function filterSchemas(query) {
    const q = query.toLowerCase().trim();
    const cards = document.querySelectorAll('.schema-card');
    cards.forEach(card => {
        const name = card.dataset.schemaName || '';
        const fields = card.dataset.fields || '';
        const match = !q || name.includes(q) || fields.includes(q);
        card.style.display = match ? '' : 'none';
    });
}

// =====================================================================
// Trace Overlay
// =====================================================================

function loadTraceData(data) {
    traceData = data;

    // Pre-compute max duration for heat-mapping
    if (traceData.processes) {
        let maxDur = 0;
        for (const pid of Object.keys(traceData.processes)) {
            const d = traceData.processes[pid].duration_ms;
            if (d !== undefined && d > maxDur) maxDur = d;
        }
        traceData._maxDuration = maxDur || 1000;
    }

    document.getElementById('trace-clear-btn').style.display = '';
    document.getElementById('trace-info').textContent = 'Trace loaded: ' + (traceData.name || Object.keys(traceData.processes || {}).length + ' processes');

    // Re-render state machine if on that view
    if (currentView === 'sm') renderStateMachine();
}

function clearTraceData() {
    traceData = null;
    document.getElementById('trace-clear-btn').style.display = 'none';
    document.getElementById('trace-info').textContent = '';
    if (currentView === 'sm') renderStateMachine();
}

// =====================================================================
// Comparison View
// =====================================================================

const ALL_SPEC_PATHS = [
    'specs/claude-code.yaml', 'specs/babyagi.yaml', 'specs/react.yaml',
    'specs/rag.yaml', 'specs/autogpt.yaml', 'specs/crew.yaml',
    'specs/code_reviewer.yaml', 'specs/babyagi_autogen.yaml', 'specs/debate.yaml',
    'specs/tree_of_thought.yaml', 'specs/plan_and_solve.yaml', 'specs/self_refine.yaml',
    'specs/voyager.yaml', 'specs/lats.yaml', 'specs/multi_agent_codegen.yaml',
    'specs/map_reduce.yaml', 'specs/socratic_tutor.yaml', 'specs/reflexion.yaml',
    'specs/mixture_of_agents.yaml', 'specs/meta_prompting.yaml',
    'specs/customer_support_swarm.yaml', 'specs/software_team.yaml'
];
let allSpecs = null;

async function loadAllSpecs() {
    if (allSpecs) return allSpecs;
    const results = await Promise.all(ALL_SPEC_PATHS.map(async path => {
        try {
            const resp = await fetch(path + (path.includes('?') ? '&' : '?') + '_t=' + Date.now());
            const text = await resp.text();
            return jsyaml.load(text);
        } catch { return null; }
    }));
    allSpecs = results.filter(Boolean);
    return allSpecs;
}

async function renderComparison() {
    const container = document.getElementById('compare-view');
    container.innerHTML = '<div style="text-align:center;padding:60px;color:#484f58;">Loading all specs...</div>';

    const specs = await loadAllSpecs();

    function count(arr) { return (arr || []).length; }
    function hasType(s, type) { return (s.processes || []).some(p => p.type === type); }
    function entityTypes(s, type) { return (s.entities || []).filter(e => e.type === type); }
    function edgeTypes(s, type) { return (s.edges || []).filter(e => e.type === type); }
    function models(s) {
        const m = new Set();
        (s.entities || []).forEach(e => { if (e.model) m.add(e.model); });
        return [...m];
    }

    const maxEntities = Math.max(...specs.map(s => count(s.entities)));
    const maxProcesses = Math.max(...specs.map(s => count(s.processes)));
    const maxEdges = Math.max(...specs.map(s => count(s.edges)));
    const maxSchemas = Math.max(...specs.map(s => count(s.schemas)));

    function bar(val, max, color) {
        const pct = max > 0 ? Math.round((val / max) * 60) : 0;
        return `<span class="cmp-bar" style="width:${pct}px;background:${color};"></span>${val}`;
    }

    let html = `<div class="compare-header"><h2>Agent Comparison</h2><p>${specs.length} agents loaded from specs</p></div>`;
    html += '<table class="compare-table"><thead><tr><th></th>';
    for (const s of specs) {
        html += `<th>${s.name || 'Unknown'}</th>`;
    }
    html += '</tr></thead><tbody>';

    html += '<tr><td>Description</td>';
    for (const s of specs) {
        const desc = (s.description || '').substring(0, 80);
        html += `<td style="font-size:0.9em;color:#8b949e;text-align:left;">${desc}${s.description && s.description.length > 80 ? '...' : ''}</td>`;
    }
    html += '</tr>';

    html += '<tr><td>Entities</td>';
    for (const s of specs) html += `<td>${bar(count(s.entities), maxEntities, '#4ecdc4')}</td>`;
    html += '</tr>';

    html += '<tr><td>Agents</td>';
    for (const s of specs) {
        const agents = entityTypes(s, 'agent');
        html += `<td>${agents.map(a => `<span class="cmp-tag">${a.label || a.id}</span>`).join(' ') || '<span class="cmp-no">-</span>'}</td>`;
    }
    html += '</tr>';

    html += '<tr><td>Stores</td>';
    for (const s of specs) {
        const stores = entityTypes(s, 'store');
        html += `<td>${stores.map(st => `<span class="cmp-tag">${st.store_type || 'store'}: ${st.label || st.id}</span>`).join(' ') || '<span class="cmp-no">-</span>'}</td>`;
    }
    html += '</tr>';

    html += '<tr><td>Tools</td>';
    for (const s of specs) {
        const tools = entityTypes(s, 'tool');
        html += `<td>${tools.length > 0 ? `<span class="cmp-count" style="color:#f39c12;">${tools.length}</span>` : '<span class="cmp-no">-</span>'}</td>`;
    }
    html += '</tr>';

    html += '<tr><td>Processes</td>';
    for (const s of specs) html += `<td>${bar(count(s.processes), maxProcesses, '#c0c0c0')}</td>`;
    html += '</tr>';

    html += '<tr><td>Gates</td>';
    for (const s of specs) {
        const gates = (s.processes || []).filter(p => p.type === 'gate');
        html += `<td>${gates.length > 0 ? `<span class="cmp-yes">${gates.length}</span>` : '<span class="cmp-no">0</span>'}</td>`;
    }
    html += '</tr>';

    html += '<tr><td>Edges</td>';
    for (const s of specs) html += `<td>${bar(count(s.edges), maxEdges, '#3498db')}</td>`;
    html += '</tr>';

    html += '<tr><td>Loops</td>';
    for (const s of specs) {
        const loops = edgeTypes(s, 'loop');
        html += `<td>${loops.length > 0 ? '<span class="cmp-yes">Yes</span>' : '<span class="cmp-no">No</span>'}</td>`;
    }
    html += '</tr>';

    html += '<tr><td>Schemas</td>';
    for (const s of specs) html += `<td>${bar(count(s.schemas), maxSchemas, '#d2a8ff')}</td>`;
    html += '</tr>';

    html += '<tr><td>Models</td>';
    for (const s of specs) {
        const m = models(s);
        html += `<td>${m.map(mm => `<span class="cmp-tag">${mm}</span>`).join(' ') || '<span class="cmp-no">-</span>'}</td>`;
    }
    html += '</tr>';

    html += '<tr><td>Entry Point</td>';
    for (const s of specs) {
        html += `<td style="color:#7ee787;">${s.entry_point || '-'}</td>`;
    }
    html += '</tr>';

    html += '<tr><td>Edge Types</td>';
    for (const s of specs) {
        const types = new Set((s.edges || []).map(e => e.type));
        html += `<td>${[...types].map(t => `<span class="cmp-tag" style="background:${EDGE_COLORS[t] ? `rgba(${hexToRgb(EDGE_COLORS[t])},0.1)` : 'rgba(88,166,255,0.08)'};color:${EDGE_COLORS[t] || '#58a6ff'};border-color:${EDGE_COLORS[t] ? `rgba(${hexToRgb(EDGE_COLORS[t])},0.2)` : 'rgba(88,166,255,0.15)'};">${t}</span>`).join(' ')}</td>`;
    }
    html += '</tr>';

    html += '<tr><td>Complexity</td>';
    for (const s of specs) {
        const score = count(s.entities) + count(s.processes) + count(s.edges) + count(s.schemas);
        const maxScore = Math.max(...specs.map(ss => count(ss.entities) + count(ss.processes) + count(ss.edges) + count(ss.schemas)));
        const pct = Math.round((score / maxScore) * 100);
        html += `<td><div style="background:#21262d;border-radius:3px;height:8px;width:100%;"><div style="background:#58a6ff;border-radius:3px;height:8px;width:${pct}%;"></div></div><div style="font-size:0.85em;color:#484f58;margin-top:2px;">${score}</div></td>`;
    }
    html += '</tr>';

    html += '</tbody></table>';
    container.innerHTML = html;
}

function hexToRgb(hex) {
    const r = parseInt(hex.slice(1,3), 16);
    const g = parseInt(hex.slice(3,5), 16);
    const b = parseInt(hex.slice(5,7), 16);
    return `${r},${g},${b}`;
}

// -- Init --
initInteraction();

// Tab switching
document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => switchView(btn.dataset.view));
});

document.getElementById('spec-select').addEventListener('change', (ev) => {
    loadSpec(ev.target.value);
});

// Trace file loading
document.getElementById('trace-load-btn').addEventListener('click', () => {
    document.getElementById('trace-file-input').click();
});
document.getElementById('trace-file-input').addEventListener('change', (ev) => {
    const file = ev.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const data = JSON.parse(e.target.result);
            loadTraceData(data);
        } catch (err) {
            alert('Invalid trace JSON: ' + err.message);
        }
    };
    reader.readAsText(file);
    ev.target.value = '';
});
document.getElementById('trace-clear-btn').addEventListener('click', clearTraceData);

loadSpec('specs/claude-code.yaml');
</script>
</body>
</html>
