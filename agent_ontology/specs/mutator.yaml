# ═══════════════════════════════════════════════════════════════
# Mutator Agent — Agent Spec (Agent Ontology v0.2)
# ═══════════════════════════════════════════════════════════════
# An agent that improves other agent specs. Takes a target spec,
# failure data, and benchmark description, then outputs an improved
# spec YAML. The meta-evolution layer evolves this mutator itself.

name: "Mutator"
version: "1.0"
description: "Meta-agent that diagnoses failures in a target agent spec and produces an improved version. Used in meta-evolution to evolve the evolver itself."
entry_point: receive_task

# ── Entities ─────────────────────────────────────────────────

entities:

  - id: diagnostician
    type: agent
    label: "Diagnostician Agent"
    model: gemini-3-flash-preview
    system_prompt: |
      You are an expert agent architecture diagnostician. You receive:
      1. An agent spec (YAML describing the agent's architecture)
      2. A failure summary (specific examples where the agent failed)
      3. A benchmark description (what the benchmark tests)

      Your job: analyze WHY the agent fails on these examples. Consider:
      - Is the agent missing a reasoning step?
      - Are the prompts too vague or missing format instructions?
      - Is data not flowing correctly between steps?
      - Is the agent missing a validation or review step?
      - Could the agent benefit from a different tool strategy?

      Output JSON with:
      - "diagnosis": a concise explanation of the root cause (1-3 sentences)
      - "fix_type": one of "edit_prompt", "add_step", "modify_logic", "add_review", "restructure"
      - "fix_details": specific instructions for what to change (be precise about which entity/process to modify and exactly what the change should be)
    input_schema: DiagnosisInput
    output_schema: DiagnosisOutput


# ── Processes ────────────────────────────────────────────────

processes:

  - id: receive_task
    type: step
    label: "Receive Task"
    description: "Accept the improvement task inputs"
    data_out: MutationTask
    logic: |
      print(f"    Spec to improve: {state.data.get('spec_yaml', '')[:80]}...")
      print(f"    Failures: {state.data.get('failure_summary', '')[:80]}...")
      print(f"    Benchmark: {state.data.get('benchmark_description', '')[:80]}...")

  - id: diagnose
    type: step
    label: "Diagnose Failures"
    description: "Invoke the diagnostician agent to analyze why the spec fails"
    data_in: DiagnosisInput
    data_out: DiagnosisOutput
    logic: |
      print(f"    Diagnosing failures...")

  - id: apply_mutation
    type: step
    label: "Apply Mutation"
    description: "Call editor LLM directly to produce raw YAML (avoids JSON wrapping)"
    data_in: EditorInput
    data_out: EditorOutput
    logic: |
      print(f"    Applying mutation: {state.data.get('fix_type', 'unknown')} — {state.data.get('fix_details', '')[:80]}...")
      _sys = (
          "You are an agent spec editor. You receive a complete agent spec in YAML format, "
          "a diagnosis explaining what's wrong, and fix details explaining what to change.\n\n"
          "Your job: output the COMPLETE IMPROVED spec as valid YAML.\n\n"
          "Rules:\n"
          "- Output ONLY valid YAML — no JSON wrapping, no markdown fences, no explanation\n"
          "- Include ALL sections: name, version, description, entry_point, entities, processes, edges, schemas\n"
          "- Make targeted changes based on the fix_details\n"
          "- Keep all entity IDs, process IDs, and schema names consistent with edges\n"
          "- Do NOT change model fields\n"
          "- Do NOT add comments — just the YAML content\n"
          "- Start your output with 'name:' on the first line\n\n"
          "Your ENTIRE response must be a valid YAML document."
      )
      _user = (
          f"## Original Spec\n\n{state.data.get('spec_yaml', '')}\n\n"
          f"## Diagnosis\n\n{state.data.get('diagnosis', '')}\n\n"
          f"## Fix Type\n\n{state.data.get('fix_type', '')}\n\n"
          f"## Fix Details\n\n{state.data.get('fix_details', '')}\n\n"
          "Output the complete improved spec as valid YAML. Start with 'name:' on the first line."
      )
      _resp = call_llm("gemini-3-flash-preview", _sys, _user, temperature=0.3, max_tokens=8192)
      state.data["mutated_spec_yaml"] = _resp.strip()
      state.data["changes_summary"] = state.data.get("fix_details", "")
      print(f"    Editor output: {len(_resp)} chars")

  - id: validate_output
    type: step
    label: "Validate Output"
    description: "Check that the mutated spec is valid YAML with required sections"
    data_in: EditorOutput
    data_out: ValidationResult
    logic: |
      import yaml as _yaml
      import re as _re
      spec_text = state.data.get("mutated_spec_yaml", "")
      # Strip markdown fences if present (editor should output raw YAML)
      if spec_text:
          m = _re.search(r'```(?:yaml)?\s*\n(.*?)```', spec_text, _re.DOTALL)
          if m:
              spec_text = m.group(1).strip()
              state.data["mutated_spec_yaml"] = spec_text
      try:
          parsed = _yaml.safe_load(spec_text)
          if not isinstance(parsed, dict):
              state.data["is_valid"] = False
              state.data["validation_error"] = "Parsed YAML is not a dict"
          elif not all(k in parsed for k in ("entities", "processes", "edges")):
              state.data["is_valid"] = False
              state.data["validation_error"] = "Missing required sections: entities, processes, or edges"
          else:
              state.data["is_valid"] = True
              state.data["validation_error"] = ""
              print(f"    Validation passed: {len(parsed.get('entities', []))} entities, {len(parsed.get('processes', []))} processes, {len(parsed.get('edges', []))} edges")
      except Exception as e:
          state.data["is_valid"] = False
          state.data["validation_error"] = str(e)
      if not state.data.get("is_valid"):
          print(f"    Validation failed: {state.data.get('validation_error', '')[:100]}")

  - id: emit_result
    type: step
    label: "Emit Result"
    description: "Output the final spec YAML (improved if valid, original if mutation failed)"
    data_out: MutatorOutput
    logic: |
      if state.data.get("is_valid"):
          state.data["final_spec_yaml"] = state.data.get("mutated_spec_yaml", "")
          state.data["mutation_applied"] = True
          print(f"    Emitting improved spec ({len(state.data['final_spec_yaml'])} chars)")
      else:
          state.data["final_spec_yaml"] = state.data.get("spec_yaml", "")
          state.data["mutation_applied"] = False
          print(f"    Mutation failed validation, returning original spec")
      state.data["answer"] = state.data["final_spec_yaml"]
      state.data["_done"] = True

# ── Edges ────────────────────────────────────────────────────

edges:

  - type: flow
    from: receive_task
    to: diagnose
    label: "Pass task to diagnostician"

  - type: invoke
    from: diagnose
    to: diagnostician
    label: "Diagnose failures"
    input: DiagnosisInput
    output: DiagnosisOutput

  - type: flow
    from: diagnose
    to: apply_mutation
    label: "Pass diagnosis to editor"

  - type: flow
    from: apply_mutation
    to: validate_output
    label: "Validate the mutation"

  - type: flow
    from: validate_output
    to: emit_result
    label: "Emit final result"

# ── Schemas ──────────────────────────────────────────────────

schemas:

  - name: MutationTask
    description: "The improvement task inputs"
    fields:
      - { name: spec_yaml, type: string }
      - { name: failure_summary, type: string }
      - { name: benchmark_description, type: string }

  - name: DiagnosisInput
    description: "Input to the diagnostician agent"
    fields:
      - { name: spec_yaml, type: string }
      - { name: failure_summary, type: string }
      - { name: benchmark_description, type: string }

  - name: DiagnosisOutput
    description: "Output from the diagnostician agent"
    fields:
      - { name: diagnosis, type: string }
      - { name: fix_type, type: string }
      - { name: fix_details, type: string }

  - name: EditorInput
    description: "Input to the editor agent"
    fields:
      - { name: spec_yaml, type: string }
      - { name: diagnosis, type: string }
      - { name: fix_type, type: string }
      - { name: fix_details, type: string }

  - name: EditorOutput
    description: "Output from the editor agent"
    fields:
      - { name: mutated_spec_yaml, type: string }
      - { name: changes_summary, type: string }

  - name: ValidationResult
    description: "Result of validating the mutated spec"
    fields:
      - { name: is_valid, type: boolean }
      - { name: validation_error, type: string }

  - name: MutatorOutput
    description: "Final output with the improved or original spec"
    fields:
      - { name: final_spec_yaml, type: string }
      - { name: mutation_applied, type: boolean }
      - { name: changes_summary, type: string }
      - { name: diagnosis, type: string }
