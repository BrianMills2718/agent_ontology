#!/usr/bin/env python3
"""
Code Review Agent — Generated by OpenClaw Instantiation Engine
Spec: Automated code review agent that analyzes pull requests with specialized reviewers and synthesizes a final review, looping until quality is satisfactory.
"""

import json
import os
import sys
import time
from datetime import datetime

# ═══════════════════════════════════════════════════════════
# Trace Log
# ═══════════════════════════════════════════════════════════

TRACE = []

def trace_call(agent_label, model, system_prompt, user_message, response, duration_ms):
    entry = {
        "timestamp": datetime.now().isoformat(),
        "agent": agent_label,
        "model": model,
        "system_prompt": system_prompt,
        "user_message": user_message,
        "response": response,
        "duration_ms": duration_ms,
    }
    TRACE.append(entry)
    print(f"    [{agent_label}] ({model}, {duration_ms}ms)")
    print(f"      IN:  {user_message[:300]}")
    print(f"      OUT: {response[:300]}")


def dump_trace(path="trace.json"):
    with open(path, "w") as f:
        json.dump(TRACE, f, indent=2)
    print(f"\nTrace written to {path} ({len(TRACE)} calls)")

# ═══════════════════════════════════════════════════════════
# LLM Call Infrastructure
# ═══════════════════════════════════════════════════════════

def call_llm(model, system_prompt, user_message, temperature=0.7, max_tokens=4096):
    if model.startswith("claude") or model.startswith("anthropic"):
        return _call_anthropic(model, system_prompt, user_message, temperature, max_tokens)
    elif model.startswith("gemini"):
        return _call_gemini(model, system_prompt, user_message, temperature, max_tokens)
    else:
        return _call_openai(model, system_prompt, user_message, temperature, max_tokens)


def _call_openai(model, system_prompt, user_message, temperature, max_tokens):
    try:
        from openai import OpenAI
        client = OpenAI()
        response = client.chat.completions.create(
            model=model,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_message},
            ],
            temperature=temperature,
            max_tokens=max_tokens,
        )
        return response.choices[0].message.content
    except Exception as e:
        print(f"[STUB] Would call OpenAI {model} — {user_message[:80]}")
        return json.dumps({"stub": True, "model": model})


def _call_anthropic(model, system_prompt, user_message, temperature, max_tokens):
    try:
        import anthropic
        client = anthropic.Anthropic()
        response = client.messages.create(
            model=model,
            max_tokens=max_tokens,
            system=system_prompt,
            messages=[{"role": "user", "content": user_message}],
        )
        return response.content[0].text
    except Exception as e:
        print(f"[STUB] Would call Anthropic {model} — {user_message[:80]}")
        return json.dumps({"stub": True, "model": model})


def _call_gemini(model, system_prompt, user_message, temperature, max_tokens):
    try:
        from google import genai
        client = genai.Client(api_key=os.environ.get("GEMINI_API_KEY", ""))
        response = client.models.generate_content(
            model=model,
            contents=f"{system_prompt}\n\n{user_message}",
            config={"temperature": temperature, "max_output_tokens": max_tokens},
        )
        return response.text
    except Exception as e:
        print(f"[STUB] Would call Gemini {model} — {user_message[:80]}")
        return json.dumps({"stub": True, "model": model})

# ═══════════════════════════════════════════════════════════
# Schema Registry
# ═══════════════════════════════════════════════════════════

SCHEMAS = {
    "PRInput": {
        "description": """Input data for a pull request""",
        "fields": [{"name": "diff", "type": "string"}, {"name": "files", "type": "list<string>"}, {"name": "description", "type": "string"}],
    },
    "PRMetadata": {
        "description": """Stored pull request metadata""",
        "fields": [{"name": "diff", "type": "string"}, {"name": "files", "type": "list<string>"}, {"name": "description", "type": "string"}],
    },
    "SecurityReview": {
        "description": """Structured security review output""",
        "fields": [{"name": "issues", "type": "list<Issue>"}, {"name": "summary", "type": "string"}],
    },
    "StyleReview": {
        "description": """Structured style review output""",
        "fields": [{"name": "issues", "type": "list<Issue>"}, {"name": "summary", "type": "string"}],
    },
    "LogicReview": {
        "description": """Structured logic review output""",
        "fields": [{"name": "issues", "type": "list<Issue>"}, {"name": "summary", "type": "string"}],
    },
    "Issue": {
        "description": """A single review issue""",
        "fields": [{"name": "severity", "type": "enum[critical, warning, info]"}, {"name": "file", "type": "string"}, {"name": "line", "type": "integer"}, {"name": "description", "type": "string"}],
    },
    "SynthesizerInput": {
        "description": """Input to the lead reviewer synthesizer""",
        "fields": [{"name": "security_review", "type": "SecurityReview"}, {"name": "style_review", "type": "StyleReview"}, {"name": "logic_review", "type": "LogicReview"}],
    },
    "SynthesizedReview": {
        "description": """Final synthesized review output""",
        "fields": [{"name": "quality_score", "type": "integer"}, {"name": "issues", "type": "list<Issue>"}, {"name": "recommendation", "type": "enum[approve, request changes, comment]"}, {"name": "summary", "type": "string"}],
    },
    "PRStoreData": {
        "description": """Data stored in the PR key-value store""",
        "fields": [{"name": "pr_metadata", "type": "PRMetadata"}, {"name": "review_history", "type": "list<SynthesizedReview>"}],
    },
}


def build_input(state, schema_name):
    """Build an input dict for an agent call using schema field names.
    Pulls matching keys from state.data."""
    schema = SCHEMAS.get(schema_name)
    if not schema:
        return state.data
    result = {}
    for field in schema["fields"]:
        fname = field["name"]
        if fname in state.data:
            result[fname] = state.data[fname]
    return result


def output_instruction(schema_name):
    """Generate a JSON output instruction string for the LLM."""
    schema = SCHEMAS.get(schema_name)
    if not schema:
        return ""
    fields = ", ".join(f'"{f["name"]}": <{f["type"]}>' for f in schema["fields"])
    return f"\n\nRespond with ONLY valid JSON matching this schema: {{{fields}}}"


def parse_response(response, schema_name):
    """Parse an LLM response according to an output schema.
    Returns a dict of field values, or {"raw": response} if parsing fails."""
    # Try to extract JSON from the response
    text = response.strip()
    # Handle markdown code blocks
    if text.startswith("```"):
        lines = text.split("\n")
        lines = lines[1:]  # skip ```json
        if lines and lines[-1].strip() == "```":
            lines = lines[:-1]
        text = "\n".join(lines)
    try:
        parsed = json.loads(text)
        if isinstance(parsed, dict):
            return parsed
        return {"value": parsed}
    except json.JSONDecodeError:
        # Try to find JSON object in the response
        start = text.find("{")
        end = text.rfind("}") + 1
        if start >= 0 and end > start:
            try:
                return json.loads(text[start:end])
            except json.JSONDecodeError:
                pass
        return {"raw": response}


# ═══════════════════════════════════════════════════════════
# Stores
# ═══════════════════════════════════════════════════════════

class Store_pr_store:
    """PR Metadata and Review Store (kv)"""
    def __init__(self):
        self.data = {}

    def read(self, key=None):
        return self.data if key is None else self.data.get(key)

    def write(self, value, key=None):
        if key is not None:
            self.data[key] = value
        else:
            self.data = value



# ═══════════════════════════════════════════════════════════
# Agent Wrappers
# ═══════════════════════════════════════════════════════════

def invoke_intake_agent(user_message, output_schema=None):
    """Intake Agent"""
    system = """You receive pull request metadata including diff, files changed, and PR description. Store the PR metadata for downstream analysis.
"""
    if output_schema:
        system += output_instruction(output_schema)
    t0 = time.time()
    result = call_llm(
        model="gemini-3-flash-preview",
        system_prompt=system,
        user_message=user_message,
        temperature=0.7,
        max_tokens=4096,
    )
    trace_call("Intake Agent", "gemini-3-flash-preview", system, user_message, result, int((time.time()-t0)*1000))
    return result


def invoke_security_reviewer(user_message, output_schema=None):
    """Security Reviewer"""
    system = """You analyze the full pull request diff for security vulnerabilities such as SQL injection, XSS, hardcoded secrets, and other risks. Provide a structured review of security issues.
"""
    if output_schema:
        system += output_instruction(output_schema)
    t0 = time.time()
    result = call_llm(
        model="gemini-3-flash-preview",
        system_prompt=system,
        user_message=user_message,
        temperature=0.7,
        max_tokens=4096,
    )
    trace_call("Security Reviewer", "gemini-3-flash-preview", system, user_message, result, int((time.time()-t0)*1000))
    return result


def invoke_style_reviewer(user_message, output_schema=None):
    """Style Reviewer"""
    system = """You analyze the full pull request diff for code style issues including naming conventions, formatting consistency, and style guide adherence. Provide a structured style review.
"""
    if output_schema:
        system += output_instruction(output_schema)
    t0 = time.time()
    result = call_llm(
        model="gemini-3-flash-preview",
        system_prompt=system,
        user_message=user_message,
        temperature=0.7,
        max_tokens=4096,
    )
    trace_call("Style Reviewer", "gemini-3-flash-preview", system, user_message, result, int((time.time()-t0)*1000))
    return result


def invoke_logic_reviewer(user_message, output_schema=None):
    """Logic Reviewer"""
    system = """You analyze the full pull request diff for logical errors, edge cases, and performance issues. Provide a structured logic review.
"""
    if output_schema:
        system += output_instruction(output_schema)
    t0 = time.time()
    result = call_llm(
        model="gemini-3-flash-preview",
        system_prompt=system,
        user_message=user_message,
        temperature=0.7,
        max_tokens=4096,
    )
    trace_call("Logic Reviewer", "gemini-3-flash-preview", system, user_message, result, int((time.time()-t0)*1000))
    return result


def invoke_lead_reviewer(user_message, output_schema=None):
    """Lead Reviewer"""
    system = """You synthesize the security, style, and logic reviews into a single structured review. Provide an overall quality score (1-10), a list of issues with severity (critical/warning/info), file, line, and description, and a summary recommendation (approve, request changes, or comment).
"""
    if output_schema:
        system += output_instruction(output_schema)
    t0 = time.time()
    result = call_llm(
        model="gemini-3-flash-preview",
        system_prompt=system,
        user_message=user_message,
        temperature=0.7,
        max_tokens=4096,
    )
    trace_call("Lead Reviewer", "gemini-3-flash-preview", system, user_message, result, int((time.time()-t0)*1000))
    return result



# ═══════════════════════════════════════════════════════════
# Agent State
# ═══════════════════════════════════════════════════════════

class AgentState:
    """Runtime state for Code Review Agent"""
    def __init__(self):
        self.pr_store = Store_pr_store()
        self.data = {}  # current data flowing through the pipeline
        self.iteration = 0


# ═══════════════════════════════════════════════════════════
# Process Functions
# ═══════════════════════════════════════════════════════════

def process_intake_pr(state):
    """
    Intake Pull Request
    Receive PR metadata and store it
    """
    print(f"  → Intake Pull Request")

    # Logic from spec
    # Store the PR metadata in state.data for downstream use
    state.data["pr_metadata"] = state.data.get("pr_metadata", {})
    # Assume input contains pr_diff, pr_files, pr_description
    # Store as is for reviewers
    state.data["pr_metadata"]["diff"] = state.data.get("diff", "")
    state.data["pr_metadata"]["files"] = state.data.get("files", [])
    state.data["pr_metadata"]["description"] = state.data.get("description", "")
    # Save to store will be done in write edge
    if state.data.get("_done"):
        return state

    # Write: Store PR metadata
    pr_store_write = build_input(state, "PRMetadata")
    state.pr_store.write(pr_store_write)

    return state


def process_analyze_security(state):
    """
    Analyze Security
    Prepare and send PR metadata to Security Reviewer
    """
    print(f"  → Analyze Security")

    # Logic from spec
    # Pass full PR metadata to security reviewer
    state.data["security_input"] = state.data.get("pr_metadata", {})
    if state.data.get("_done"):
        return state

    # Invoke: Invoke Security Reviewer
    security_reviewer_input = build_input(state, "PRMetadata")
    security_reviewer_msg = json.dumps(security_reviewer_input, default=str)
    security_reviewer_raw = invoke_security_reviewer(security_reviewer_msg, output_schema="SecurityReview")
    security_reviewer_result = parse_response(security_reviewer_raw, "SecurityReview")
    # Merge output fields into state.data
    state.data.update(security_reviewer_result)
    state.data["security_review"] = security_reviewer_result
    state.data["analyze_security_result"] = security_reviewer_result
    print(f"    ← Security Reviewer: {security_reviewer_result}")

    return state


def process_analyze_style(state):
    """
    Analyze Style
    Prepare and send PR metadata to Style Reviewer
    """
    print(f"  → Analyze Style")

    # Logic from spec
    # Pass full PR metadata to style reviewer
    state.data["style_input"] = state.data.get("pr_metadata", {})
    if state.data.get("_done"):
        return state

    # Invoke: Invoke Style Reviewer
    style_reviewer_input = build_input(state, "PRMetadata")
    style_reviewer_msg = json.dumps(style_reviewer_input, default=str)
    style_reviewer_raw = invoke_style_reviewer(style_reviewer_msg, output_schema="StyleReview")
    style_reviewer_result = parse_response(style_reviewer_raw, "StyleReview")
    # Merge output fields into state.data
    state.data.update(style_reviewer_result)
    state.data["style_review"] = style_reviewer_result
    state.data["analyze_style_result"] = style_reviewer_result
    print(f"    ← Style Reviewer: {style_reviewer_result}")

    return state


def process_analyze_logic(state):
    """
    Analyze Logic
    Prepare and send PR metadata to Logic Reviewer
    """
    print(f"  → Analyze Logic")

    # Logic from spec
    # Pass full PR metadata to logic reviewer
    state.data["logic_input"] = state.data.get("pr_metadata", {})
    if state.data.get("_done"):
        return state

    # Invoke: Invoke Logic Reviewer
    logic_reviewer_input = build_input(state, "PRMetadata")
    logic_reviewer_msg = json.dumps(logic_reviewer_input, default=str)
    logic_reviewer_raw = invoke_logic_reviewer(logic_reviewer_msg, output_schema="LogicReview")
    logic_reviewer_result = parse_response(logic_reviewer_raw, "LogicReview")
    # Merge output fields into state.data
    state.data.update(logic_reviewer_result)
    state.data["logic_review"] = logic_reviewer_result
    state.data["analyze_logic_result"] = logic_reviewer_result
    print(f"    ← Logic Reviewer: {logic_reviewer_result}")

    return state


def process_synthesize_review(state):
    """
    Synthesize Review
    Combine all three reviews into a single structured review
    """
    print(f"  → Synthesize Review")

    # Logic from spec
    # Combine security, style, and logic reviews into one input for lead reviewer
    state.data["synth_input"] = {
      "security_review": state.data.get("security_review", {}),
      "style_review": state.data.get("style_review", {}),
      "logic_review": state.data.get("logic_review", {})
    }
    if state.data.get("_done"):
        return state

    # Invoke: Invoke Lead Reviewer
    lead_reviewer_input = build_input(state, "SynthesizerInput")
    lead_reviewer_msg = json.dumps(lead_reviewer_input, default=str)
    lead_reviewer_raw = invoke_lead_reviewer(lead_reviewer_msg, output_schema="SynthesizedReview")
    lead_reviewer_result = parse_response(lead_reviewer_raw, "SynthesizedReview")
    # Merge output fields into state.data
    state.data.update(lead_reviewer_result)
    state.data["synthesized_review"] = lead_reviewer_result
    state.data["synthesize_review_result"] = lead_reviewer_result
    print(f"    ← Lead Reviewer: {lead_reviewer_result}")

    return state


def process_post_review(state):
    """
    Post Review
    Post synthesized review as PR comment and update store
    """
    print(f"  → Post Review")

    # Logic from spec
    # Here would be logic to post comment to PR (external)
    # Update review history in store
    state.data["review_to_post"] = state.data.get("synthesized_review", {})
    if state.data.get("_done"):
        return state

    # Write: Store review history
    pr_store_write = build_input(state, "SynthesizedReview")
    state.pr_store.write(pr_store_write)

    return state


def process_check_quality(state):
    """
    Is Quality Score >= 7?
    """
    print(f"  → Is Quality Score >= 7?")

    # Gate: quality_score >= 7
    # Branch: yes → end_process
    # Branch: no → request_fixes

    if (state.data.get("quality_score", 0)) >= 7:
        print(f"    → yes")
        return "end_process"
    else:
        print(f"    → no")
        return "request_fixes"


def process_request_fixes(state):
    """
    Request Fixes from User
    """
    print(f"  → Request Fixes from User")

    response = input("The review quality score is below 7. Please address the issues and push new commits. [fixes pushed]: ").strip().lower()
    state.data["checkpoint_response"] = response
    return state


def process_wait_for_new_commits(state):
    """
    Wait for New Commits
    """
    print(f"  → Wait for New Commits")

    response = input("Waiting for new commits to be pushed after requested fixes. [new commits pushed]: ").strip().lower()
    state.data["checkpoint_response"] = response
    return state


def process_end_process(state):
    """
    End Process
    Review process complete with satisfactory quality score
    """
    print(f"  → End Process")

    # Logic from spec
    state.data["_done"] = True
    if state.data.get("_done"):
        return state

    return state


# ═══════════════════════════════════════════════════════════
# State Machine Executor
# ═══════════════════════════════════════════════════════════

PROCESSES = {
    "intake_pr": process_intake_pr,
    "analyze_security": process_analyze_security,
    "analyze_style": process_analyze_style,
    "analyze_logic": process_analyze_logic,
    "synthesize_review": process_synthesize_review,
    "post_review": process_post_review,
    "check_quality": process_check_quality,
    "request_fixes": process_request_fixes,
    "wait_for_new_commits": process_wait_for_new_commits,
    "end_process": process_end_process,
}

TRANSITIONS = {
    "intake_pr": ['analyze_security', 'analyze_style', 'analyze_logic'],  # fan-out
    "analyze_security": "synthesize_review",
    "analyze_style": "synthesize_review",
    "analyze_logic": "synthesize_review",
    "synthesize_review": "post_review",
    "post_review": "check_quality",
    # "check_quality": determined by gate logic
    "request_fixes": "wait_for_new_commits",
    "wait_for_new_commits": "intake_pr",
    "end_process": None,  # terminal
}


MAX_ITERATIONS = 100


def run(initial_data=None):
    """Code Review Agent — main execution loop"""
    state = AgentState()
    if initial_data:
        state.data.update(initial_data)

    current = "intake_pr"
    print(f"\n════════════════════════════════════════════════════════════")
    print(f"  Code Review Agent")
    print(f"  Automated code review agent that analyzes pull requests with specialized reviewers and synthesizes a final review, looping until quality is satisfactory.")
    print(f"════════════════════════════════════════════════════════════\n")

    while current and state.iteration < MAX_ITERATIONS:
        state.iteration += 1
        print(f"\n[Iteration {state.iteration}] State: {current}")

        process_fn = PROCESSES.get(current)
        if not process_fn:
            print(f"  Unknown process: {current}")
            break

        result = process_fn(state)

        if current in ['check_quality']:
            current = result
        else:
            current = TRANSITIONS.get(current)

        # Fan-out: if transition is a list, run all branches sequentially
        while isinstance(current, list):
            _targets = current
            for _ft in _targets:
                state.iteration += 1
                print(f"\n[Iteration {state.iteration}] State: {_ft} (fan-out)")
                _fn = PROCESSES.get(_ft)
                if _fn:
                    _fn(state)
            current = TRANSITIONS.get(_targets[-1])

        if current is None or state.data.get("_done"):
            print("\n  [DONE] Reached terminal state.")
            break

    if state.iteration >= MAX_ITERATIONS:
        print(f"\n  [STOPPED] Max iterations ({MAX_ITERATIONS}) reached.")

    dump_trace()
    print(f"\nFinal state.data keys: {list(state.data.keys())}")
    return state


if __name__ == "__main__":
    run()